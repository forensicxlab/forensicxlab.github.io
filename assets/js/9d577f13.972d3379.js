"use strict";(self.webpackChunkexhume=self.webpackChunkexhume||[]).push([[6171],{4798:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var o=n(8535),a=n(4848),s=n(8453);const i={slug:"voliat",title:"\ud83d\udce6 Volatility3 : Import Address Table",authors:["k1nd0ne"],tags:["DFIR","Volatility","Memory Forensics","Windows"]},r=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Windows PE Format",id:"windows-pe-format",level:2},{value:"Interactions with the memory",id:"interactions-with-the-memory",level:3},{value:"The Import Address Table (IAT)",id:"the-import-address-table-iat",level:3},{value:"Extracting the IAT using volatility3",id:"extracting-the-iat-using-volatility3",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",sup:"sup",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Windows executable analysis is a key aspect of Digital Forensics and Reverse Malware Engineering. Identifying the capabilities of a program can help to target potential malicious code and orient the later reverse code analysis phase. In this blogpost, we will dive into the structure of the Windows Portable Executable (PE) and how we can extract the imported functions in the context of memory analysis."}),"\n",(0,a.jsx)(t.h2,{id:"windows-pe-format",children:"Windows PE Format"}),"\n",(0,a.jsxs)(t.p,{children:["A portable executable (PE) ",(0,a.jsx)(t.sup,{children:(0,a.jsx)(t.a,{href:"#user-content-fn-1-efcee2",id:"user-content-fnref-1-efcee2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," is a file format used by Windows to store executable programs, libraries (DLLs) and object files. It contains all the necessary information for the operating system to load and execute the program. The program is therefore well structured. Here is a representation of the PE structure for a Windows system ",(0,a.jsx)(t.sup,{children:(0,a.jsx)(t.a,{href:"#user-content-fn-2-efcee2",id:"user-content-fnref-2-efcee2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),":"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"alt text",src:n(5669).A+"",title:"PE Structure (simplified)",width:"318",height:"558"})}),"\n",(0,a.jsxs)(t.p,{children:["The PE starts with the well-known DOS, Stub and NT headers. It is also composed of multiple sections. Each section as its own purpose, for example the .text section contains the byte codes corresponding to the instructions of the program. We will see that there are specific sections that exists which might help the analyst to identify the capabilities of an executable without starting the reverse code analysis phase. If you want to learn more about the PE format, the articles from 0xRick about the subject are very well explained ",(0,a.jsx)(t.sup,{children:(0,a.jsx)(t.a,{href:"#user-content-fn-2-efcee2",id:"user-content-fnref-2-efcee2-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"interactions-with-the-memory",children:"Interactions with the memory"}),"\n",(0,a.jsx)(t.p,{children:"In the context of memory analysis, we need to understand what is happening when a Windows executable is loaded. The operating system will map the PE file from the disk to memory by first creating a dedicated virtual address space. Then, the headers are parsed and loaded to learn about important information about the sections (entry point, size, ...). Once parsed, the memory allocation is performed to load the actual content of the sections. The PE file often depends on external libraries, the operating system resolves the imports by looking up the required functions in the corresponding DLLs and update the memory addresses accordingly. A library can be \u201cbound\u201d to the PE which means it is directly integrated inside the code section. This is often used for better performances."}),"\n",(0,a.jsx)(t.h3,{id:"the-import-address-table-iat",children:"The Import Address Table (IAT)"}),"\n",(0,a.jsxs)(t.p,{children:["The Import Address Table is located inside the \u201c.idata\u201d Section ",(0,a.jsx)(t.sup,{children:(0,a.jsx)(t.a,{href:"#user-content-fn-3-efcee2",id:"user-content-fnref-3-efcee2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})})," of a PE, it can be seen as a table of references indicating to the loader which functions are needed from the imported DLL by the program. This table is a copy of the Import Lookup Table (ILT), but once in memory, the IAT is overwritten with the actual addresses of the functions that are being imported which is interesting from the memory forensics standpoint."]}),"\n",(0,a.jsx)(t.h2,{id:"extracting-the-iat-using-volatility3",children:"Extracting the IAT using volatility3"}),"\n",(0,a.jsxs)(t.p,{children:["Carving the IAT during memory forensics can be very valuable for the analyst to look for API call patterns associated with malware behavior. For example, the OpenProcess, VirtualAllocEx, CreateRemoteThread function present inside the IAT of a PE can be a good indicator for potential code injection ",(0,a.jsx)(t.sup,{children:(0,a.jsx)(t.a,{href:"#user-content-fn-4-efcee2",id:"user-content-fnref-4-efcee2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})}),". The analyst can also pivot on some of the functions to identify for example the arguments that can be passed."]}),"\n",(0,a.jsx)(t.p,{children:"A volatility3 plugin can be made to extract the IAT information from the memory. Below is an example output of the created plugin named \u201cwindows.iat.IAT\u201d. For each process, the associated PE sections are parsed in order to find the IAT. Next, all of the imported functions are displayed to the analyst as well as if the associated DLL is bounded or not to the executable."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"~\xbb vol -r pretty -f Triage-Memory.mem windows.iat --pid 3496\nVolatility 3 Framework 2.5.1\nFormatting...0.00               PDB scanning finished\n  |  PID |           Name |      Library | Bound |                        Function |  Address\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                            _iob | 0x80c0c8\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                _except_handler3 | 0x80c0cc\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                  __set_app_type | 0x80c0d0\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                      __p__fmode | 0x80c0d4\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                    __p__commode | 0x80c0d8\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                    _adjust_fdiv | 0x80c0dc\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                __setusermatherr | 0x80c0e0\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                       _initterm | 0x80c0e4\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                   __getmainargs | 0x80c0e8\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                   __p___initenv | 0x80c0ec\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                     _XcptFilter | 0x80c0f0\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                           _exit | 0x80c0f4\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                         _onexit | 0x80c0f8\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                     __dllonexit | 0x80c0fc\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                         strrchr | 0x80c100\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                         wcsncmp | 0x80c104\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                          _close | 0x80c108\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                          wcslen | 0x80c10c\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                          wcscpy | 0x80c110\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                        strerror | 0x80c114\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                            modf | 0x80c118\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                          strspn | 0x80c11c\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                         realloc | 0x80c120\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                    __p__environ | 0x80c124\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                   __p__wenviron | 0x80c128\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                          _errno | 0x80c12c\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                            free | 0x80c130\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                         strncmp | 0x80c134\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                          strstr | 0x80c138\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                         strncpy | 0x80c13c\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                           _ftol | 0x80c140\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                           qsort | 0x80c144\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                           fopen | 0x80c148\n* | 3496 | UWkpjFjDzM.exe |   MSVCRT.dll | False |                          perror | 0x80c14c\n[TRUNCATED]\n"})}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsxs)(t.p,{children:["The extraction of the IAT can be very useful for the analyst to identify the capabilities of a process in memory and gather context to better orient the reverse code analysis phase. When the analyst is willing to understand some of the Windows API functions, the Microsoft documentation is often explaining everything ",(0,a.jsx)(t.sup,{children:(0,a.jsx)(t.a,{href:"#user-content-fn-5-efcee2",id:"user-content-fnref-5-efcee2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"5"})}),". Trying to look for some of the functions in the text section and extracting the value of the arguments can be the subject of a future blogpost. The pluging is available here and a pull request is in progress ",(0,a.jsx)(t.a,{href:"https://github.com/forensicxlab/volatility3/tree/feature/IAT",children:"https://github.com/forensicxlab/volatility3/tree/feature/IAT"})]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["Do not hesitate to reach me at ",(0,a.jsx)(t.a,{href:"mailto:felix.guyard@forensicxlab.com",children:"felix.guyard@forensicxlab.com"})," to enhance this article or to comment on the integration to the volatility framework."]}),"\n"]}),"\n","\n",(0,a.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,a.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{id:"user-content-fn-1-efcee2",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/windows/win32/debug/pe-format",children:"https://learn.microsoft.com/en-us/windows/win32/debug/pe-format"})," ",(0,a.jsx)(t.a,{href:"#user-content-fnref-1-efcee2","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{id:"user-content-fn-2-efcee2",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://0xrick.github.io/win-internals/pe2/#dos-header",children:"https://0xrick.github.io/win-internals/pe2/#dos-header"})," ",(0,a.jsx)(t.a,{href:"#user-content-fnref-2-efcee2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})," ",(0,a.jsxs)(t.a,{href:"#user-content-fnref-2-efcee2-2","data-footnote-backref":"","aria-label":"Back to reference 2-2",className:"data-footnote-backref",children:["\u21a9",(0,a.jsx)(t.sup,{children:"2"})]})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{id:"user-content-fn-3-efcee2",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table",children:"https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#import-address-table"})," ",(0,a.jsx)(t.a,{href:"#user-content-fnref-3-efcee2","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{id:"user-content-fn-4-efcee2",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://www.apriorit.com/dev-blog/679-windows-dll-injection-for-api-hooks",children:"https://www.apriorit.com/dev-blog/679-windows-dll-injection-for-api-hooks"})," ",(0,a.jsx)(t.a,{href:"#user-content-fnref-4-efcee2","data-footnote-backref":"","aria-label":"Back to reference 4",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{id:"user-content-fn-5-efcee2",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/windows/win32/api/",children:"https://learn.microsoft.com/en-us/windows/win32/api/"})," ",(0,a.jsx)(t.a,{href:"#user-content-fnref-5-efcee2","data-footnote-backref":"","aria-label":"Back to reference 5",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},5669:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/1-daca747f861ae57a39ac6507d382ad44.png"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var o=n(6540);const a={},s=o.createContext(a);function i(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:t},e.children)}},8535:e=>{e.exports=JSON.parse('{"permalink":"/blog/voliat","source":"@site/blog/2023-12-16-voliat/index.md","title":"\ud83d\udce6 Volatility3 : Import Address Table","description":"Windows executable analysis is a key aspect of Digital Forensics and Reverse Malware Engineering. Identifying the capabilities of a program can help to target potential malicious code and orient the later reverse code analysis phase. In this blogpost, we will dive into the structure of the Windows Portable Executable (PE) and how we can extract the imported functions in the context of memory analysis.","date":"2023-12-16T00:00:00.000Z","tags":[{"inline":true,"label":"DFIR","permalink":"/blog/tags/dfir"},{"inline":true,"label":"Volatility","permalink":"/blog/tags/volatility"},{"inline":true,"label":"Memory Forensics","permalink":"/blog/tags/memory-forensics"},{"inline":true,"label":"Windows","permalink":"/blog/tags/windows"}],"readingTime":5.895,"hasTruncateMarker":true,"authors":[{"name":"k1nd0ne","title":"Digital Forensics Spiderman","url":"https://github.com/k1n0ne","page":{"permalink":"/blog/authors/k-1-nd-0-ne"},"socials":{"x":"https://x.com/k1nd0ne","github":"https://github.com/k1nd0ne","bluesky":"https://bsky.app/profile/k1nd0ne.bsky.social"},"imageURL":"https://avatars.githubusercontent.com/u/27780432?v=4","key":"k1nd0ne"}],"frontMatter":{"slug":"voliat","title":"\ud83d\udce6 Volatility3 : Import Address Table","authors":["k1nd0ne"],"tags":["DFIR","Volatility","Memory Forensics","Windows"]},"unlisted":false,"prevItem":{"title":"\ud83e\udd89 Thanatology Part 1 - Introducing the Thanatology project","permalink":"/blog/thanatology"},"nextItem":{"title":"\ud83d\udce6 Volatility3 : Alternate Data Stream Scan","permalink":"/blog/volads"}}')}}]);