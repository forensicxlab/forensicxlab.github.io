"use strict";(self.webpackChunkexhume=self.webpackChunkexhume||[]).push([[9897],{2212:e=>{e.exports=JSON.parse('{"permalink":"/blog/vmdk","source":"@site/blog/2025-06-14-vmdk/index.md","title":"\ud83d\udd26 A quick walkthrough in the VMDK format","description":"After attending a conference for incident response teams, I joined a project aiming to create a forensic framework allowing acquisition and visualization of evidence from various sources: the Exhume toolkit.","date":"2025-06-14T00:00:00.000Z","tags":[{"inline":true,"label":"VMDK","permalink":"/blog/tags/vmdk"},{"inline":true,"label":"Exhume","permalink":"/blog/tags/exhume"},{"inline":true,"label":"Digital Forensics","permalink":"/blog/tags/digital-forensics"}],"readingTime":9.96,"hasTruncateMarker":true,"authors":[{"name":"mickaelwalter","title":"Infosec and technology enthousiast","url":"https://github.com/MickaelWalter/","page":{"permalink":"/blog/authors/mickaelwalter"},"socials":{"x":"https://x.com/mickaelwalter","github":"https://github.com/MickaelWalter","bluesky":"https://bsky.app/profile/mickaelwalter.bsky.social"},"imageURL":"https://www.mickaelwalter.fr/content/images/2020/05/hackerman-profile.png","key":"mickaelwalter"}],"frontMatter":{"slug":"vmdk","title":"\ud83d\udd26 A quick walkthrough in the VMDK format","authors":["mickaelwalter"],"tags":["VMDK","Exhume","Digital Forensics"]},"unlisted":false,"prevItem":{"title":"\ud83e\udd89 Thanatology part 2: Multiple disk images formats handling using the Exhume ToolKit","permalink":"/blog/thanatology-2"},"nextItem":{"title":"\ud83e\udd89 Thanatology Part 1 - Introducing the Thanatology project","permalink":"/blog/thanatology"}}')},7056:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>h});var s=i(2212),a=i(4848),n=i(8453);const r={slug:"vmdk",title:"\ud83d\udd26 A quick walkthrough in the VMDK format",authors:["mickaelwalter"],tags:["VMDK","Exhume","Digital Forensics"]},o="A format of formats",l={authorsImageUrls:[void 0]},h=[];function d(e){const t={a:"a",code:"code",h1:"h1",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"After attending a conference for incident response teams, I joined a project aiming to create a forensic framework allowing acquisition and visualization of evidence from various sources: the Exhume toolkit."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://www.forensicxlab.com/docs/exhume",children:"The Exhume Toolkit v0.1"})}),"\n",(0,a.jsx)(t.p,{children:"In this quest of retrieving data from various base formats, I got involved in the understanding and implementation of a parser for the VMDK format."}),"\n",(0,a.jsx)(t.p,{children:"The Virtual Machine Disk format has been created by VMware and is used by all kinds of virtual machines from all types of hypervisors. It is also used in exchange formats used to share virtual machines from one hypervisor to another."}),"\n",(0,a.jsx)(t.p,{children:"Most IT experts, from cybersecurity to system administrators have heard of VMDK files. And I am no exception. But I never really understood what was behind this format. Sure, I did encounter some difficulties to access data from a VMDK file sourced from and ESXi server but I always found tools allowing to convert the file to a better suited format... Including VMDK itself."}),"\n",(0,a.jsx)(t.p,{children:"At that moment I wondered why converting a VMDK file to another one could help me get access to the data for forensic purposes. And I've found the answer now I did some serious research on the matter."}),"\n",(0,a.jsx)(t.p,{children:"The VMDK is not one file format by itself but rather a collection of formats depending on the configuration set up for the virtual machine. Many parameters can have an impact on the way the virtual machine data will be stored:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Whether the disk is thin provisioned or not"}),"\n",(0,a.jsx)(t.li,{children:"Whether the disk image is stored in a file, a full hardware disk or a partitioned disk"}),"\n",(0,a.jsx)(t.li,{children:"Whether the disk is divided in several files or not"}),"\n",(0,a.jsx)(t.li,{children:"Whether the data is compressed or not"}),"\n",(0,a.jsx)(t.li,{children:"Whether the file represents a snapshot or a full disk"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"At the beginning, there is one thing in common for all formats: the descriptor file."}),"\n",(0,a.jsx)(t.p,{children:"The descriptor file bears its name well and contains the metadata about a VMDK disk allowing to read and write data to the virtual disk."}),"\n",(0,a.jsx)(t.p,{children:"It is a text description, usually in a separate text file, of various parameters related to the disk itself: disk ID, adapter type, but most importantly a list of references to what is described as extents."}),"\n",(0,a.jsx)(t.p,{children:"Extents are the actual files, disks or partitions containing the data on the virtual disk. They can be of various forms determined by a parameter specified on each line."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://www.mickaelwalter.fr/content/images/2025/06/image-2.png",alt:""})}),"\n",(0,a.jsx)(t.p,{children:"Typical scenario of a descriptor file and its associated extents"}),"\n",(0,a.jsx)(t.p,{children:"A descriptor file can look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'    # Disk DescriptorFile\n    version=1\n    encoding="UTF-8"\n    CID=fffffffe\n    parentCID=ffffffff\n    createType="twoGbMaxExtentFlat"\n\n    # Extent description\n    RW 2097152 FLAT "Disque virtuel 2-f001.vmdk" 0\n\n    # The Disk Data Base\n    #DDB\n\n    ddb.adapterType = "lsilogic"\n    ddb.geometry.cylinders = "512"\n    ddb.geometry.heads = "128"\n    ddb.geometry.sectors = "32"\n    ddb.longContentID = "d0f5e5f69fcd0241f710a9dcfffffffe"\n    ddb.uuid = "60 00 C2 96 41 d4 0c 4b-bc 3a 43 31 4c d0 b4 09"\n    ddb.virtualHWVersion = "21"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["The descriptor file above specifies a disk of type ",(0,a.jsx)(t.code,{children:"2GbMaxExtentFlat"}),". This means that the disk is built around extent files of maximum 2GB that contain the actual data in a flat manner (the disk data is stored in a raw form). The extent description section will notably describe the number of sectors of 512 bytes for each extent and the start sector of the extent (here 2 097 152 sectors starting at sector 0)."]}),"\n",(0,a.jsx)(t.p,{children:"So, we have a type for the disk as a whole and a type for each extent individually. It starts with a mess for newcomers, isn't it?"}),"\n",(0,a.jsx)(t.p,{children:"I won't dive in details on disk types. Mostly they will give a bit more details on the reasons extents are segmented in a certain way (in a single file or not, full disk, partition, etc.)."}),"\n",(0,a.jsx)(t.p,{children:"What interests me the most today is the way data is stored in the extents. Extents can also be one of several types:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Flat : the data is stored as is in the file"}),"\n",(0,a.jsx)(t.li,{children:'Sparse : the data is stored in "grains" allowing to allocate only what\'s necessary'}),"\n",(0,a.jsx)(t.li,{children:"Zero : there is no data, just zeros (in this case, no extent path is specified)"}),"\n",(0,a.jsx)(t.li,{children:"VMFS : somewhat similar to flat but on ESXi servers"}),"\n",(0,a.jsx)(t.li,{children:"VMFSSparse : a sparse variant for ESXi servers"}),"\n",(0,a.jsx)(t.li,{children:"And others I won't dive in today"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["The VMDK descriptor is usually in the ",(0,a.jsx)(t.code,{children:"<name>.vmdk"})," file. Extents can be in other files such as ",(0,a.jsx)(t.code,{children:"<name>-flat.vmdk"}),", ",(0,a.jsx)(t.code,{children:"<name>-f001.vmdk"}),", or ",(0,a.jsx)(t.code,{children:"<name>-s001.vmdk"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Let's dive in the different extent types."}),"\n",(0,a.jsx)(t.h1,{id:"flat-vmfs-and-zero",children:"Flat, VMFS and Zero"}),"\n",(0,a.jsx)(t.p,{children:"Flat and VMFS extent types are basically the same type. They store raw data in the extent. That is, if you read data at byte 0 of the first extent, you will read the first byte of the virtual disk itself."}),"\n",(0,a.jsx)(t.p,{children:"There can be some hiccups when the disk is segmented in several files in terms of how offsets must be handled (because the file is not starting at sector 0) but that's it."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://www.mickaelwalter.fr/content/images/2025/06/image-3.png",alt:""})}),"\n",(0,a.jsx)(t.p,{children:"In the case of flat extents, data is stored sequentially and can be accessed by determining which sector must be retrieved. Knowing the sector number allows to determine the proper extent file and the proper offset inside the file itself"}),"\n",(0,a.jsx)(t.p,{children:"Flat and VMFS files cannot be thin provisioned and the combined size of such extents will be exactly the capacity of the disk with zeros located in places that have not been written yet. There is no header, no metadata including in the extents. Only the disk data."}),"\n",(0,a.jsx)(t.p,{children:"Flat and VMFS files always have a separate plaintext descriptor file and are easy to identify through it as it is easy to open in a regular text editor."}),"\n",(0,a.jsx)(t.p,{children:"The zero extent is only a virtual extent spitting out zeros."}),"\n",(0,a.jsx)(t.h1,{id:"sparse",children:"Sparse"}),"\n",(0,a.jsx)(t.p,{children:"The sparse extent types appear when a disk is thin provisioned (when the size of the disk specified at the virtual machine creation is not fully allocated immediately)."}),"\n",(0,a.jsx)(t.p,{children:'The sparse extent files are binary files following a specific format. They start with the "KDMV" magic bytes (VDMK in little endian) and a header that will indicate the top-level metadata needed to read the file.'}),"\n",(0,a.jsx)(t.p,{children:"It is important to note that a sparse extent file is segmented in blocks of 512 bytes. As such, the header is 512 bytes long with padding to fill up the whole sector. All subsequent references in the file are specified in terms of sectors of this size."}),"\n",(0,a.jsxs)(t.p,{children:["There is a special case in ",(0,a.jsx)(t.code,{children:"monolithicSparse"})," disks where the VMDK descriptor is not in a separate file but is embedded directly into the sparse extent file. In this case, the sparse file header will give the sector number where to locate the descriptor and the sector count it will take"]}),"\n",(0,a.jsx)(t.p,{children:"The header of a sparse file contains a lot of metadata related to the way the data is organized. This is necessary because the disk contents are not organized sequentially."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://www.mickaelwalter.fr/content/images/2025/06/image-4.png",alt:""})}),"\n",(0,a.jsx)(t.h1,{id:"overview-of-the-structure-of-a-sparse-file",children:"Overview of the structure of a sparse file"}),"\n",(0,a.jsx)(t.p,{children:"To allow full understanding of this overview, we have to dive in the nature of a grain."}),"\n",(0,a.jsx)(t.p,{children:"A grain is a group of sectors. The number of the sectors grouped in a grain is specified by a parameter in the header (it is usually set to 128)."}),"\n",(0,a.jsx)(t.p,{children:"So, in a sparse file the disk data is split in blocks of several 512-byte long sectors. Grains in which no data has been written are not provisioned (sparse grain) in the file and the corresponding entry in the grain table is set to 0 indicating that any byte retrieved from it should be 0."}),"\n",(0,a.jsx)(t.p,{children:"Let's talk about the grain directory and the grain table."}),"\n",(0,a.jsx)(t.p,{children:"The grain directory is a list of sector numbers pointing to various grain tables that can be placed anywhere in the sparse file. Each grain table will point to the first sector (relative to the start of the file and not the disk in this case) of the corresponding grain in the file."}),"\n",(0,a.jsx)(t.p,{children:"In the grain directory and grain tables, grains are sorted in the same order as on the actual disk: the first entry of the first table pointed by the directory is the first sector of the disk part sliced in this sparse file (remember that a extent file does not necessarily start at sector 0 of the disk)."}),"\n",(0,a.jsx)(t.p,{children:"All the sectors of a provisioned grain are written fully in the file. A typical example of that is the sector 0 of a disk partitioned with a Master Boot Record. The MBR is usually 512-byte long. In this case, the grain 0 is provisioned and will contain data only in the first sector. All the other 127 (in case, the grain size is 128) are often set to 0."}),"\n",(0,a.jsx)(t.p,{children:"The primary and secondary grain directories usually exist together to ensure resiliency in case of data corruption. Despite this, there are some cases where only the secondary directory should be used. A flag indicates which on to use depending on the case."}),"\n",(0,a.jsx)(t.p,{children:"The file format explained before has 2 other variants:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"VMFS sparse: similar to the Sparse format but with several Copy-On-Write files"}),"\n",(0,a.jsx)(t.li,{children:"StreamOptimized sparse file: used in exchange formats such as OVA, this is a sparse file but with grain data compressed (using ZLIB DEFLATE)"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In the first case, the file header format changes and contains more metadata allowing a root / children relationship between files."}),"\n",(0,a.jsx)(t.p,{children:"In the second case, the file also contains markers that allow to read the file sequentially. It is still possible to refer to the data using the contents of the header rather than reading the whole file but it should be taken into account that a marker starts the grain and not the actual data. Moreover, even if when they are decompressed they have a fixed size, the compressed grains can be of variable length and may be the source of irregular repartition of grains in the file."}),"\n",(0,a.jsx)(t.p,{children:"I won't dive into these special cases as they work on the same principles as the sparse extent type."}),"\n",(0,a.jsx)(t.h1,{id:"retrieving-data-for-forensic-purposes",children:"Retrieving data for forensic purposes"}),"\n",(0,a.jsx)(t.p,{children:"A challenge encountered by the forensic analyst when working with VMDK file is often to be able to retrieve the disk data in a reproducible and demonstrable way. Most forensic tools require a flat VMDK image to be able to work on the data. And you now see why this is the case."}),"\n",(0,a.jsx)(t.p,{children:"However, flat images are not the norm as disks are most of the time thin provisioned to spare disk space on the host. This requires a conversion of the VMDK files to a monolithic flat one."}),"\n",(0,a.jsx)(t.p,{children:"VMware (now Broadcom) provides such conversion tools but they are mostly closed source and there is no warranty of the integrity of data."}),"\n",(0,a.jsx)(t.p,{children:"That's okay for most investigations but some require high levels of integrity."}),"\n",(0,a.jsx)(t.p,{children:"In this case, the most sensible approach is to directly parse the original source without any attempt to convert it. This is the approach I used in my contribution to Exhume Body. It is not a complete coverage of all VMDK formats yet but feedbacks and samples will be useful for me to improve the module."}),"\n",(0,a.jsx)(t.p,{children:"You can find the source here:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://github.com/forensicxlab/exhume_body",children:"GitHub - forensicxlab/exhume_body: Exhume a body of data. Supports multiple file formats."})}),"\n",(0,a.jsx)(t.p,{children:"Don't hesitate to rise an issue or PR to improve this module."}),"\n",(0,a.jsx)(t.h1,{id:"a-bit-more-documentation",children:"A bit more documentation"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://github.com/libyal/libvmdk/blob/main/documentation/VMWare%20Virtual%20Disk%20Format%20(VMDK).asciidoc",children:"libvmdk/documentation/VMWare Virtual Disk Format (VMDK).asciidoc at main \xb7 libyal/libvmdk"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://vdc-download.vmware.com/vmwb-repository/dcr-public/2bba164b-4115-4279-9c99-40f4c14319ad/03a845fc-5345-45de-9a27-31e868d6e751/doc/vddkDataStruct.5.3.html#1020737",children:"Virtual Disk Types"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"http://sanbarrow.com/vmdk/disktypes.html",children:"sanbarrow.com"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://venthusiastic.wordpress.com/2014/03/12/vmdk/",children:"https://venthusiastic.wordpress.com/2014/03/12/vmdk/"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://az4n6.blogspot.com/2015/04/dealing-with-compressed-vmdk-files.html",children:"Dealing with compressed vmdk files"})})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>o});var s=i(6540);const a={},n=s.createContext(a);function r(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);