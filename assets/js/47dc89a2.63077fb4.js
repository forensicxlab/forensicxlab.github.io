"use strict";(self.webpackChunkexhume=self.webpackChunkexhume||[]).push([[6015],{794:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/exhume-cfc5a6ed6adf759a0d93dcbdffa6adcb.svg"},2172:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/diskimg2-3d37476d5f1d12126c19336781c9bc34.svg"},4495:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/diskimg1-b62b14a2d792b6378f871efbac2cdd5e.svg"},4953:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/exhume_body-802a8a683cacf077e424a11cf88a0a2a.svg"},6467:e=>{e.exports=JSON.parse('{"permalink":"/blog/thanatology-2","source":"@site/blog/2025-06-30-thanatology-2/index.md","title":"\ud83e\udd89 Thanatology part 2: Multiple disk images formats handling using the Exhume ToolKit","description":"This blogpost is part of the Thanatology blogpost series. If you haven\u2019t check it out, I recommend reading the following first:","date":"2025-06-30T00:00:00.000Z","tags":[{"inline":true,"label":"Thanatology","permalink":"/blog/tags/thanatology"},{"inline":true,"label":"Exhume","permalink":"/blog/tags/exhume"},{"inline":true,"label":"Digital Forensics","permalink":"/blog/tags/digital-forensics"}],"readingTime":11.21,"hasTruncateMarker":true,"authors":[{"name":"k1nd0ne","title":"Digital Forensics Spiderman","url":"https://github.com/k1n0ne","page":{"permalink":"/blog/authors/k-1-nd-0-ne"},"socials":{"x":"https://x.com/k1nd0ne","github":"https://github.com/k1nd0ne","bluesky":"https://bsky.app/profile/k1nd0ne.bsky.social"},"imageURL":"https://avatars.githubusercontent.com/u/27780432?v=4","key":"k1nd0ne"}],"frontMatter":{"slug":"thanatology-2","title":"\ud83e\udd89 Thanatology part 2: Multiple disk images formats handling using the Exhume ToolKit","authors":["k1nd0ne"],"tags":["Thanatology","Exhume","Digital Forensics"]},"unlisted":false,"prevItem":{"title":"\ud83e\udd89 Thanatology part 3: MBR and GPT forensics with the Exhume ToolKit.","permalink":"/blog/thanatology-3"},"nextItem":{"title":"\ud83d\udd26 A quick walkthrough in the VMDK format","permalink":"/blog/vmdk"}}')},8019:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>f,contentTitle:()=>d,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>r});var a=i(6467),n=i(4848),o=i(8453);const s={slug:"thanatology-2",title:"\ud83e\udd89 Thanatology part 2: Multiple disk images formats handling using the Exhume ToolKit",authors:["k1nd0ne"],tags:["Thanatology","Exhume","Digital Forensics"]},d=void 0,f={authorsImageUrls:[void 0]},r=[{value:"Disk images in digital forensics",id:"disk-images-in-digital-forensics",level:2},{value:"Logical Vs Physical Acquisitions",id:"logical-vs-physical-acquisitions",level:3},{value:"The disk image formats ecosystem",id:"the-disk-image-formats-ecosystem",level:3},{value:"What are we left with?",id:"what-are-we-left-with",level:3},{value:"Exhume Body: Disk Image data abstraction",id:"exhume-body-disk-image-data-abstraction",level:2},{value:"Using Exhume Body with the CLI",id:"using-exhume-body-with-the-cli",level:3},{value:"Using Exhume Body as a Library",id:"using-exhume-body-as-a-library",level:3},{value:"Conclusion",id:"conclusion",level:2}];function b(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"This blogpost is part of the Thanatology blogpost series. If you haven\u2019t check it out, I recommend reading the following first:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.forensicxlab.com/blog/thanatology",children:"Thanatology part 1: Introduction to the Thanatology project"})}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["In this blogpost, we will dive into the concepts of disk images and how digital forensics examiners can use the ",(0,n.jsx)(t.a,{href:"https://www.forensicxlab.com/docs/exhume",children:"Exhume toolkit"})," to read data transparently from different formats. First, we will give an overview of what is a disk image and describe some of the existing formats one may encounter during a digital investigation. Next, we will explore how Exhume Body is providing an abstraction layer to those formats to read data agnostically."]}),"\n",(0,n.jsx)(t.h2,{id:"disk-images-in-digital-forensics",children:"Disk images in digital forensics"}),"\n",(0,n.jsxs)(t.p,{children:["A disk image is a ",(0,n.jsx)(t.strong,{children:"complete"})," copy of the contents of a digital storage device, such as a hard drive, solid-state drive (SSD), USB stick, CD/DVD, Virtual Machine, etc. It captures every bit of data stored on the device, including user files, system files, and even hidden or deleted information. In digital forensics, disk images are crucial because they allow investigators to preserve and analyze data without altering the original evidence. By working from an image rather than the actual device, forensic analysts ensure the integrity of the evidence is maintained, which is essential for legal proceedings and maintaining a chain of custody."]}),"\n",(0,n.jsx)(t.h3,{id:"logical-vs-physical-acquisitions",children:"Logical Vs Physical Acquisitions"}),"\n",(0,n.jsxs)(t.p,{children:["There are two primary types of acquisitions in digital forensics: ",(0,n.jsx)(t.strong,{children:"physical acquisition"})," and ",(0,n.jsx)(t.strong,{children:"logical acquisition"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Physical acquisition involves creating a bit-for-bit copy of the entire storage device, including slack space, unallocated space, and hidden partitions. This type of acquisition is more comprehensive and enables deeper forensic analysis, such as recovering deleted files or analyzing remnants of previously stored data."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(4495).A+"",width:"1866",height:"725"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Logical acquisition"}),", on the other hand, captures only the files and directories visible to the operating system. While faster and less storage-intensive, logical acquisition may miss important data that resides outside the active file system, making it less thorough for forensic purposes."]}),"\n",(0,n.jsx)(t.p,{children:"Choosing between logical and physical acquisition depends mostly on the context of the digital forensic investigation case. However a chain of custody must be respected in each case, documenting the actions taken before, during and after the acquisition."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(2172).A+"",width:"2539",height:"1479"})}),"\n",(0,n.jsx)(t.h3,{id:"the-disk-image-formats-ecosystem",children:"The disk image formats ecosystem"}),"\n",(0,n.jsx)(t.p,{children:"When performing a full acquisition of a disk (whether it is a physical disk or an existing disk image from a Virtual Environnement for example without compression) you will always need to store the forensic copy on a storage device that possess at least the same storage capacity as the source disk copy you have to make. The storage capacity is increasing with the years which means the need to find ways to compress those images to be able to store more data was growing. That\u2019s where some new disk image formats come into play."}),"\n",(0,n.jsx)(t.p,{children:"Several disk image formats can be used digital forensic investigations, each with specific features and use cases. The most common formats include raw (dd), Expert Witness Format (EWF or. E01), and Advanced Forensic Format (AFF). The raw format is a simple sector-by-sector copy of the drive and is widely supported due to its simplicity and universality. However, it does not include metadata or compression which can be a bummer when facing situations with terabytes of data. EWF, developed by Guidance Software, is widely used in professional forensic environments because it supports metadata storage (like case number, examiner notes), compression, and integrity checks. If you are interested in EWF, we made a blogpost about it. AFF is an open-source format designed to be flexible and extensible while also supporting compression and metadata. The choice of format often depends on the tools available, the complexity of the case, and the need for efficient storage and documentation."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Last but not least"}),": the Virtual Disk Image formats like qcow, qcow2, vmdk , vdi, vhd or vhdx are used primarily for virtualization and emulation. Not all these formats come with compressions, but the layout is different for each and require parsing operations to obtain raw data sectors. Digital forensics examiner can also encounter such disk image format when seizing a virtual machine for example that is stored within the building of a cloud provider service. The difference (and sometimes advantage) when stepping upon such cases is that the disk image relevant for the case is already there, it functions just like a physical disk image would in a traditional forensic context. This allows to directly parse the file system, recover deleted files, analyze partition structures, and perform low-level searches without the physical disk extraction and digital copy phase. Virtual disk image also often has the capability of storing snapshots which can be very valuable for the investigator to be able to retrieve data that changed in time. If you are interested about those disk image formats, we made a ",(0,n.jsx)(t.a,{href:"https://www.forensicxlab.com/blog/vmdk",children:"blogpost about VMDK"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"what-are-we-left-with",children:"What are we left with?"}),"\n",(0,n.jsx)(t.p,{children:"When investigators deal with disk images in multiple formats, the main problem faced is compatibility and interoperability across forensic tools and workflows. Each image format has its own structure, metadata handling, compression method, and supported features, which can create significant challenges during analysis, validation, and evidence handling. The usual methodology to maximize compatibility is often to use tools and operations to convert those specific disk images into raw disk images that can later be ingested into forensics toolkits, but it can be time consuming and even generate data-loss."}),"\n",(0,n.jsx)(t.h2,{id:"exhume-body-disk-image-data-abstraction",children:"Exhume Body: Disk Image data abstraction"}),"\n",(0,n.jsx)(t.p,{children:"Exhume Body is one of the core components of the Exhume Tool Suite. It is one of the foundation modules which is trying to provide an agnostic disk image data abstraction layer for file system forensics. It is providing a way to read and seek through multiple disk image formats like if it was contiguous sectors of data like a raw image. Exhume body is designed to understand these multiple disk image formats and to perform the parsing and potential decompression operations on the fly when requesting data."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(794).A+"",width:"753",height:"381"})}),"\n",(0,n.jsx)(t.p,{children:"Exhume Body is enabling the user to read and seek through data. Like most of the Exhume modules, the user can use either the command line interface or as a library.  Let us now show some practical examples."}),"\n",(0,n.jsx)(t.h3,{id:"using-exhume-body-with-the-cli",children:"Using Exhume Body with the CLI"}),"\n",(0,n.jsxs)(t.p,{children:["After ",(0,n.jsx)(t.a,{href:"https://www.forensicxlab.com/docs/exhume_body/getting-started",children:"installing exhume"}),", we can provide the tool with the location of the target disk image, the number of bytes to read and an offset. Optionally, we can precise the format of the disk image. If no format is specified, the tool will try to discover the format automatically."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:i(4953).A+"",width:"1537",height:"236"})}),"\n",(0,n.jsx)(t.p,{children:"In the following output, we are reading the first sector (512 bytes) of an EWF Linux disk image we would like to investigate. We will pipe the result inside xxd."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"[2025-06-15T09:32:08Z INFO  exhume_body] Processing the file 'disk.E01' in 'auto' format...\n[2025-06-15T09:32:08Z INFO  exhume_body] Detected an EWF disk image.\n[2025-06-15T09:32:08Z INFO  exhume_body] Evidence : disk.E01\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf] EWF File Information:\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf] Number of Segments: 1\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf] Acquisition Metadata:\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Case Number: OSDFCon Workshop VM1\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Evidence Number: 001\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Description: Compromised Webserver\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Examiner: Ali Hadi\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Notes:\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Application Version: ADI3.4.2.2\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   OS Version: Win 201x\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Acquisition Date: 2019 10 6 17 58 15\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   System Date: 2019 10 6 17 58 15\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Password Hash: 0\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Reserved: f\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf] Volume Information:\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Chunk Count: 1032260\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Sectors Per Chunk: 64 (32768 bytes)\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Bytes Per Sector: 512\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Total Sector Count: 66064608\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf] Chunk Information:\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Segment Number: 1\n[2025-06-15T09:32:08Z INFO  exhume_body::ewf]   Number of Chunks: 1032260\n00000000: efbf bd63 efbf bd10 efbf bdd0 bc00 efbf  ...c............\n00000010: bdef bfbd 0000 efbf bdd8 8eef bfbd efbf  ................\n00000020: bdef bfbd 007c efbf bd00 06ef bfbd 0002  .....|..........\n00000030: efbf bdef bfbd 2106 0000 efbf bdef bfbd  ......!.........\n00000040: 0738 0475 0bef bfbd efbf bd10 efbf bdef  .8.u............\n00000050: bfbd efbf bd07 75ef bfbd efbf bd16 efbf  ......u.........\n00000060: bd02 efbf bd01 efbf bd00 7cef bfbd efbf  ..........|.....\n00000070: bdef bfbd 7401 efbf bd4c 02ef bfbd 13ef  ....t....L......\n00000080: bfbd 007c 0000 efbf bdef bfbd 0000 0000  ...|............\n00000090: 0000 0000 0000 0000 0000 0000 efbf bd01  ................\n000000a0: 0000 0000 0000 00ef bfbd efbf bdef bfbd  ................\n000000b0: efbf bdef bfbd c280 7405 efbf bdef bfbd  ........t.......\n000000c0: 7074 02ef bfbd efbf bdef bfbd 797c 0000  pt..........y|..\n000000d0: 31ef bfbd efbf bdd8 8ed0 bc00 20ef bfbd  1........... ...\n000000e0: efbf bd64 7c3c efbf bd74 02ef bfbd efbf  ...d|<...t......\n000000f0: bd52 efbf bd17 04ef bfbd 0703 7406 efbf  .R..........t...\n00000100: bdef bfbd 7def bfbd 1701 efbf bd05 7cef  ....}.........|.\n00000110: bfbd 41ef bfbd efbf bd55 efbf bd13 5a52  ..A......U....ZR\n00000120: 723d efbf bdef bfbd 55ef bfbd 7537 efbf  r=......U...u7..\n00000130: bdef bfbd 0174 3231 efbf bdef bfbd 4404  .....t21......D.\n00000140: 40ef bfbd 44ef bfbd efbf bd44 02ef bfbd  @...D......D....\n00000150: 0410 0066 efbf bd1e 5c7c 66ef bfbd 5c08  ...f....\\|f...\\.\n00000160: 66ef bfbd 1e60 7c66 efbf bd5c 0cef bfbd  f....`|f...\\....\n00000170: 4406 0070 efbf bd42 efbf bd13 7205 efbf  D..p...B....r...\n00000180: bd00 70ef bfbd 76ef bfbd 08ef bfbd 1373  ..p...v........s\n00000190: 0d5a efbf bdef bfbd 0fef bfbd efbf bd00  .Z..............\n000001a0: efbf bdef bfbd 7def bfbd 0066 0fef bfbd  ......}....f....\n000001b0: c688 64ef bfbd 4066 efbf bd44 040f efbf  ..d...@f...D....\n000001c0: bdef bfbd efbf bdef bfbd 02ef bfbd efbf  ................\n000001d0: bdef bfbd 40ef bfbd 4408 0fef bfbd efbf  ....@...D.......\n000001e0: bdef bfbd efbf bd02 66ef bfbd 0466 efbf  ........f....f..\n000001f0: bd60 7c66 09ef bfbd 754e 66ef bfbd 5c7c  .`|f....uNf...\\|\n00000200: 6631 efbf bd66 efbf bd34 efbf bdef bfbd  f1...f...4......\n00000210: 31ef bfbd 66ef bfbd 7404 3b44 087d 37ef  1...f...t.;D.}7.\n00000220: bfbd efbf bdef bfbd efbf bd30 efbf bdef  ...........0....\n00000230: bfbd efbf bd02 08ef bfbd efbf bdef bfbd  ................\n00000240: 5aef bfbd c6bb 0070 efbf bdef bfbd 31db  Z......p......1.\n00000250: b801 02ef bfbd 1372 1eef bfbd efbf bd60  .......r.......`\n00000260: 1eef bfbd 0001 efbf bdef bfbd 31ef bfbd  ............1...\n00000270: efbf bd00 efbf bdef bfbd efbf bdef bfbd  ................\n00000280: efbf bd1f 61ef bfbd 265a 7cef bfbd efbf  ....a...&Z|.....\n00000290: bd7d efbf bd03 efbf bdef bfbd 7def bfbd  .}..........}...\n000002a0: 3400 efbf bdef bfbd 7def bfbd 2e00 efbf  4.......}.......\n000002b0: bd18 efbf bdef bfbd 4752 5542 2000 4765  ........GRUB .Ge\n000002c0: 6f6d 0048 6172 6420 4469 736b 0052 6561  om.Hard Disk.Rea\n000002d0: 6400 2045 7272 6f72 0d0a 00ef bfbd 0100  d. Error........\n000002e0: efbf bd0e efbf bd10 efbf bd3c 0075 efbf  ...........<.u..\n000002f0: bdef bfbd 40ef bfbd 0200 0000 efbf bd20  ....@..........\n00000300: 2100 efbf bd1a 3b1f 0008 0000 00ef bfbd  !.....;.........\n00000310: 0700 003b 1b1f 05ef bfbd efbf bdef bfbd  ...;............\n00000320: efbf bdef bfbd 0700 0268 efbf bd03 0000  .........h......\n00000330: 0000 0000 0000 0000 0000 0000 0000 0000  ................\n00000340: 0000 0000 0000 0000 0000 0000 0000 55ef  ..............U.\n00000350: bfbd 0a                                  ...\n"})}),"\n",(0,n.jsx)(t.p,{children:"We can witness in the logs that exhume_body successfully retrieved the metadata about the EWF disk image and gave us the bytes we have requested. That is good if you want to dump some specific data from a specific offset to later analyse it in an other tool for example."}),"\n",(0,n.jsx)(t.h3,{id:"using-exhume-body-as-a-library",children:"Using Exhume Body as a Library"}),"\n",(0,n.jsx)(t.p,{children:"One use-case you might have the need to automate a specific parsing task from a disk image. If you are willing to program in rust (you should), you can use exhume_body as a library to perform the task you want. Here is an example."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'use exhume_body::Body;\nuse std::io::{Read, Seek, SeekFrom};\n\nfn main() {\n    // Enable log output (optional)\n    env_logger::Builder::new()\n        .filter_level(log::LevelFilter::Info)\n        .init();\n\n    // Open the evidence file \u2014 let Exhume auto-detect the image format\n    let mut body = Body::new("/path/to/evidence.E01".to_string(), "auto");\n\n    // Dump some high-level metadata to the log\n    body.print_info();\n\n    // Seek to byte offset 0x200\n    body.seek(SeekFrom::Start(0x200)).expect("seek failed");\n\n    // Read the next 0x400 bytes (1 KiB)\n    let mut buffer = vec![0u8; 0x400];\n    body.read_exact(&mut buffer).expect("read failed");\n\n    println!("Read {} bytes; first 16 bytes: {:02x?}", buffer.len(), &buffer[..16]);\n}\n\n'})}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(t.p,{children:"Exhume body is a powerfull module of the Exhume toolkit and is one of the core libary used for many other modules and part of the Thanatology project. In the next blogpost we will cover MBR and GPT partition analysis using Exhume Partitions ! Join us on Discord if you want to participate to the project."})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(b,{...e})}):b(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>d});var a=i(6540);const n={},o=a.createContext(n);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);