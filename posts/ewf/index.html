<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
  üî¶ Debunking the Expert Witness Compression Format (EWF) ¬∑ ForensicXlab
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">


<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self'; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://www.google-analytics.com https://cdn.jsdelivr.net/; prefetch-src 'self'; connect-src 'self' https://www.google-analytics.com;">




<meta name="author" content="ForensicXlab">
<meta name="description" content="Abstract Link to heading As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data. The Expert Witness Compression Format (EWF) provides a way to store metadata about the image, such as the source device, imaging tool, checksums, signatures, and other relevant information about the acquired media.">
<meta name="keywords" content="blog, DFIR">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="üî¶ Debunking the Expert Witness Compression Format (EWF)"/>
<meta name="twitter:description" content="Abstract Link to heading As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data. The Expert Witness Compression Format (EWF) provides a way to store metadata about the image, such as the source device, imaging tool, checksums, signatures, and other relevant information about the acquired media."/>

<meta property="og:title" content="üî¶ Debunking the Expert Witness Compression Format (EWF)" />
<meta property="og:description" content="Abstract Link to heading As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data. The Expert Witness Compression Format (EWF) provides a way to store metadata about the image, such as the source device, imaging tool, checksums, signatures, and other relevant information about the acquired media." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.forensicxlab.com/posts/ewf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-11T19:51:30+02:00" />
<meta property="article:modified_time" content="2023-05-11T19:51:30+02:00" />





<link rel="canonical" href="http://www.forensicxlab.com/posts/ewf/">


<link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.4897cb1d7ba929d10aabbac6e9bf40a8ecb89318118d99027cb159e38fb32b28.css" integrity="sha256-SJfLHXupKdEKq7rG6b9AqOy4kxgRjZkCfLFZ44&#43;zKyg=" crossorigin="anonymous" media="screen" />








 




<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.106.0">





  </head>




<body class="preload-transitions colorscheme-light">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      ForensicXlab
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/toolshed/">ToolShed</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/contact/">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://www.forensicxlab.com/posts/ewf/">
              üî¶ Debunking the Expert Witness Compression Format (EWF)
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2023-05-11T19:51:30&#43;02:00">
                May 11, 2023
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              11-minute read
            </span>
          </div>
          <div class="authors">
  <i class="fa fa-user" aria-hidden="true"></i>
    <a href="/authors/f%C3%A9lix-guyard/">F√©lix Guyard</a></div>

          
          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/ewf/">EWF</a>
    </span>
      <span class="separator">‚Ä¢</span>
    <span class="tag">
      <a href="/tags/digital-forensics/">Digital Forensics</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <h1 id="abstract">
  Abstract
  <a class="heading-link" href="#abstract">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data.
The Expert Witness Compression Format (EWF) provides a way to store metadata about the image, such as the source device, imaging tool, checksums, signatures, and other relevant information about the acquired media. This imaging format main asset is its compression capability thus reducing the size of the resulting image file. Compression allows for faster analysis of the data and reduces storage requirements.
This article is meant to vulgarize the structures behind an EWF Segment. The reader will discover the main algorithms to use in order to be able to read and seek inside such image format. Finally, a rust proof of concept will be shared to the reader.</p>
<h1 id="filesystem-layers-of-abstraction">
  Filesystem layers of abstraction
  <a class="heading-link" href="#filesystem-layers-of-abstraction">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>Before getting right into the main subject of this article, it is important to learn or get a little reminder about the filesystem concepts, vocabulary, and the underlying layers of abstractions.
Let us take the Unix filesystem concept as an example. Below is a vulgarized representation of the main layers of abstraction.</p>
<p><img src="/images/ewf/1.png" alt="alt text" title="Filesystem layout"></p>
<p>A storage medium (hard drive, SSD, ‚Ä¶) have the necessary set of electronics to create an abstraction of the Logical Block Addressing. It can be viewed as contiguous sequence of sectors. A sector is the smallest accessible unit on a drive (typically 512 bytes for disk drives).  It is possible to create a group multiple sectors and form a block.  Blocks are the smallest accessible units on a filesystem.  Each filesystem type can have their own concepts to represents files, directories, hardware devices etc&hellip;
The exploitation system is supplying the abstraction of those human friendly concepts via the kernel to perform various actions on the filesystem (read, write, seek&hellip;).</p>
<p>Digital forensics is performed on a copy of the media to be investigated. This can be done with various tools (FTK Imager, EnCase, dd, Falcon, others‚Ä¶) and produce an image that can have various format (raw, img, ewf, vmdk, vdi‚Ä¶) to be analyzed later without performing the investigation on the original media.</p>
<p>From a forensics perspective, when a storage media is acquired, the investigator needs to find a way to emulate all the necessary abstraction layers in order to extract specific artifacts usefull to an investigation without tempering with the data. Forensics tools are providing such abstraction and capabilities. Most of those tools support different image format. One of these formats is well known and largely used: the Expert Witness Compressing Format (EWF).</p>
<p><img src="/images/ewf/2.png" alt="alt text" title="Filesystem abstraction"></p>
<h1 id="the-expert-witness-compression-format">
  The Expert Witness Compression Format
  <a class="heading-link" href="#the-expert-witness-compression-format">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>The Expert Witness Compression Format (EWF) is a forensic image output format created by the ASRDATA company. It can be used to create a bit-by-bit copy of a digital device. It includes both data and metadata, such as the partition table and other information about the device. EWF is designed to maintain the integrity of the original data and can be compressed to reduce storage requirements. It is widely used to preserve evidence for analysis and investigation both by law enforcement, digital forensics and incident response companies. This format is not so easy to understand because it is a proprietary file format, thus the purpose of this blog article. Luckily, the opensource community provide a C library and a nice documentation about this file format <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. Let‚Äôs try to have a nice mental representation of the component of an EWF image.</p>
<h2 id="the-segments">
  The segments
  <a class="heading-link" href="#the-segments">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>An EWF image can be divided into multiple Segments (it can also be a unique segment). Those segments are files that possesses a consecutive extension system: Starting from ‚ÄúE01‚Äù to ‚ÄúE99‚Äù, then in alphabetical order from ‚ÄúEAA‚Äù to ‚ÄúZZZ‚Äù. Dividing a large sized media evidence source into multiple segments is a great way to prevent a large and unique raw output file that can sometime create problems on some filesystem. Each segment file is composed of a <strong>Header</strong> and multiple <strong>Sections</strong>.</p>
<h3 id="the-ewf-file-header-and-sections">
  The EWF file Header and Sections
  <a class="heading-link" href="#the-ewf-file-header-and-sections">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Let‚Äôs now dive into the components a EWF segment file.</p>
<p><img src="/images/ewf/3.png" alt="alt text" title="EWF structure"></p>
<p>The EWF is storing the source evidence image‚Äôs sectors inside <strong>chunks</strong>. A chunk is just a group of sectors. There is a finite number of chunks per segments. Therefore, the information about the sectors and chunks needs to be known if we want to read them.</p>
<h3 id="the-segment-file-header">
  The segment file Header
  <a class="heading-link" href="#the-segment-file-header">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Each segment file has a <strong>Header</strong> (do not confuse the segment file header with the section header described later). The Header contains a signature (or a magic number) with a size of 8 bytes that attest of its format:</p>
<p><img src="/images/ewf/4.png" alt="alt text" title="Header"></p>
<p>In this example, the signature is: ‚ÄúEVF\0x09\0x0d\0x0a\0xff\0x00‚Äù</p>
<p>The file header also contains the information about the <strong>first section offset</strong> and the segment number.</p>
<h3 id="the-sections">
  The sections
  <a class="heading-link" href="#the-sections">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The sections are the metadata of the image used by the tools to be able to read the evidence sectors and get other various information about the acquired evidence (checksums, acquisition tool used, timestamps etc‚Ä¶). Each section starts with metadata describing itself:</p>
<ul>
<li>Its type (header, volume, ‚Ä¶)</li>
<li>Its size</li>
<li>The next section offset</li>
</ul>
<p>Here is what important information you can extract from each section:</p>
<ul>
<li><strong>The header section -</strong> Not to be confused with the file header described earlier, it contains information about the acquired media (case number, Evidence Number, Examiner name, etc.). Each acquisition tools have their own way of describing what information reside in this section.</li>
<li><strong>The ‚Äúvolume‚Äù or ‚Äúdisk‚Äù section ‚Äì</strong> It contains critical information about the sectors and the chunks of the acquired media that will help the investigator to parse the EWF file like the chunk count, the size of a chunk, the size of a sector, the number of sectors per chunk.</li>
<li><strong>The sector section ‚Äì</strong> It contains the actual chunks of the acquired evidence. Now, the main advantage about EWF is that some of the chunks can be compressed to gain space on the destination storage using the zlib compression algorithm. Therefore, we need to know what the offsets of each chunk are and if it is compressed chunk or not.</li>
<li><strong>The table section ‚Äì</strong> This section is like a table of pointers that will tell the investigator where to find each chunk and if it is compressed. The most significant bit (MSB) of each pointer indicates if the chunk is compressed (1) or uncompressed (0).</li>
<li><strong>The ‚Äúend‚Äù or ‚Äúnext‚Äù section ‚Äì</strong> The ‚Äúend‚Äú section indicates that this segment file was the last one. However, the ‚Äúnext‚Äù section indicates that there is another segment to parse.</li>
</ul>
<p>You can now understand better the image showed at the beginning. To have more details about each section, the libewf project is providing a good documentation <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<h2 id="parsing-the-ewf-segments">
  Parsing the EWF Segments
  <a class="heading-link" href="#parsing-the-ewf-segments">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Now that you have a better understanding of this file format, you want to be able to write a code to create the abstraction layer needed to read data like a standard disk and beginning the extraction of evidence.</p>
<h3 id="step-1-parsing-all-the-useful-metadata-from-each-segment">
  Step 1: Parsing all the useful metadata from each segment.
  <a class="heading-link" href="#step-1-parsing-all-the-useful-metadata-from-each-segment">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>First, we want to be able to read chunks, we first need to extract all the necessary metadata about those chunks from each segment. To hold all the important metadata, we can create multiple structures to store them. Here is an example of what you can do.</p>
<p><img src="/images/ewf/5.png" alt="alt text" title="EWF structure"></p>
<p>Here, the purple color corresponds to a Structure or an Object. The red color represents an HashMap or a Dictionary with a key and a value. The blue color is a vector. You‚Äôll notice that we have created the structures representing the different headers and sections of an EWF Segment. Our main goal is:</p>
<ul>
<li>To know where all the segment file descriptors are. (segments)</li>
<li>To store all the chunk for each segment (chunks).</li>
<li>To store all the end of sector offset for each segment (end_of_sectors).</li>
<li>To know what is the current chunk that the EWF structure points to (CachedChunk).
To understand better here are the structure definitions of a Chunk and a CachedChunk:</li>
</ul>
<p><img src="/images/ewf/6.png" alt="alt text" title="Chunk structure"></p>
<p>To parse a segment here is a pseudo-code algorithm:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Algorithm: parse_segment
</span></span><span style="display:flex;"><span>Parameters: self: The EWF Structure, file: the current segment.
</span></span><span style="display:flex;"><span>Return value: EwfSegment filled with all the information about the chunks    
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Begin:
</span></span><span style="display:flex;"><span>		// Parsing EWF Header
</span></span><span style="display:flex;"><span>    self.ewf_header &lt;- new EwfHeader(file)
</span></span><span style="display:flex;"><span>    current_offset &lt;- 0xd // We place our self just after the EWFHeader.
</span></span><span style="display:flex;"><span>    ewf_section_descriptor_size &lt;- 0x4c
</span></span><span style="display:flex;"><span>    extracted_chunks &lt;- []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    begin loop:
</span></span><span style="display:flex;"><span>        // Parsing EWF section descriptor
</span></span><span style="display:flex;"><span>        section &lt;- new EwfSectionDescriptor(file, current_offset)
</span></span><span style="display:flex;"><span>        section_offset &lt;- section.next_section_offset
</span></span><span style="display:flex;"><span>        section_size &lt;- section.section_size
</span></span><span style="display:flex;"><span>        section_type &lt;- section.section_type_def
</span></span><span style="display:flex;"><span>        self.sections.push(section) // Save the section into a vector
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Saving header information
</span></span><span style="display:flex;"><span>        if section_type == &#34;header&#34; or section_type == &#34;header2&#34;:
</span></span><span style="display:flex;"><span>            self.header &lt;- new EwfHeaderSection(file, current_offset+ewf_section_descriptor_size, self.sections.last())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Saving volume information
</span></span><span style="display:flex;"><span>        if section_type == &#34;disk&#34; or section_type == &#34;volume&#34;:
</span></span><span style="display:flex;"><span>            self.volume &lt;- new EwfVolumeSection(file, current_offset+ewf_section_descriptor_size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Extracting chunks from table section
</span></span><span style="display:flex;"><span>        if section_type == &#34;table&#34;:
</span></span><span style="display:flex;"><span>            extracted_chunks.extend(self.parse_table(&amp;file, current_offset+ewf_section_descriptor_size)) //We save our chunks structure.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Saving end of sectors information
</span></span><span style="display:flex;"><span>        if section_type == &#34;sectors&#34;:
</span></span><span style="display:flex;"><span>            self.end_of_sectors.insert(self.ewf_header.segment_number, current_offset + section_size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Checking if the current section is done
</span></span><span style="display:flex;"><span>        if current_offset == section_offset or section_type == &#34;done&#34;:
</span></span><span style="display:flex;"><span>            break
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Updating the offset to go throught the segment file.
</span></span><span style="display:flex;"><span>        current_offset &lt;- section_offset
</span></span><span style="display:flex;"><span>    end loop
</span></span><span style="display:flex;"><span>    // Saving segment and extracted chunks information
</span></span><span style="display:flex;"><span>    self.segments.push(file)
</span></span><span style="display:flex;"><span>    self.chunks.insert(self.ewf_header.segment_number, extracted_chunks)
</span></span><span style="display:flex;"><span>    return self
</span></span><span style="display:flex;"><span>End
</span></span></code></pre></div><p>Notice that this function is calling other parsing functions and data structures that I did not describe in pseudo-code. The main goal is to understand the main parsing routine.</p>
<h3 id="step-2-read-an-arbitrary-chunk">
  Step 2: Read an arbitrary chunk.
  <a class="heading-link" href="#step-2-read-an-arbitrary-chunk">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Now that we have save all our chunks, we can create a function to read the chunk number <strong>X</strong> from the given segment number <strong>Y</strong>.</p>
<p>Reading a chunk includes checking if it is a compressed chunk. And if so, decompressing its data before.</p>
<ol>
<li>To read the data from a chunk number in a segment file here are the steps to follow :</li>
<li>Check if the given chunk number is valid for the given segment using the ‚Äúchunks‚Äù dictionary in our EWF structure. If not, it raises an error.</li>
<li>Use the following variables:</li>
</ol>
<ul>
<li>data: An empty buffer of bytes to store the read data.</li>
<li>chunk: A reference to the chunk object in the segment.</li>
<li>start_offset: The starting position in the segment where the chunk data is located.</li>
<li>end_offset: The ending position in the segment where the chunk data is located (for compressed chunks).</li>
</ul>
<ol start="4">
<li>Seek to the starting position of the chunk data in the segment.</li>
<li>If the chunk is not compressed, read data from the segment into a buffer.</li>
<li>If the chunk is compressed, decode the compressed data using Zlib <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> and store the result in the data buffer.</li>
<li>Return the data buffer containing the chunk data.</li>
</ol>
<p>We can now read the data from any chunk number in a given segment!</p>
<h3 id="step-3-create-a-standard-read">
  Step 3: Create a standard read
  <a class="heading-link" href="#step-3-create-a-standard-read">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Now the last step is to create a read function to imitate the traditional read system call <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> on a POSIX system. To perform this task here are the steps for a given number of bytes to read:</p>
<ol>
<li>Check if there is any cached chunk data available. If not, read the first chunk of the first segment and set it as the cached chunk data.</li>
<li>Loop until the size is zero.</li>
<li>If the remaining size of the data to be read is less than or equal to the remaining data in the cached chunk, update the buffer with the remaining data. Then update the cached chunk pointer and size.</li>
<li>If the remaining size is greater than the remaining cached chunk data, update the buffer with all the remaining cached chunk data and calculate the remaining size of the data to be read.</li>
<li>Check if there are more chunks to be read or if the end of the segments has been reached. If there are more chunks, get the next chunk number and read that chunk&rsquo;s data.</li>
<li>Otherwise, return the buffer that has been read so far (nothing more to read).</li>
</ol>
<h1 id="proof-of-concept">
  Proof of concept
  <a class="heading-link" href="#proof-of-concept">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>Now that we have finished the theorical part, I am sharing to you a proof of concept written in rust. The code can be found here: <a href="https://github.com/forensicxlab/EWF">https://github.com/forensicxlab/EWF</a></p>
<p><img src="/images/ewf/8.png" alt="alt text" title="POC"></p>
<p>This code will show you all the important metadata about the parsed segments. It is capable of:</p>
<ul>
<li>Reading and seeking through the sectors of an EWF image.</li>
<li>Parsing the MBR.</li>
<li>Calculate the original media signature (MD5 of all the sectors).</li>
</ul>
<h1 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>To conclude this blogpost, we were able to create the abstraction layer needed to read an EWF image. We can now identify partitions and create other abstraction layer to read files, reconstruct a system tree etc‚Ä¶ This can be the subject of future blogposts. Do not hesitate to reach me at <a href="mailto:felix.guyard@forensicxlab.com">felix.guyard@forensicxlab.com</a> to make this article better.</p>
<h1 id="references">
  References
  <a class="heading-link" href="#references">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://github.com/libyal/libewf/blob/main/documentation/Expert%20Witness%20Compression%20Format%20(EWF).asciidoc">https://github.com/libyal/libewf/blob/main/documentation/Expert%20Witness%20Compression%20Format%20(EWF).asciidoc</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://github.com/libyal/libewf">https://github.com/libyal/libewf</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://www.zlib.net/">https://www.zlib.net/</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://en.wikipedia.org/wiki/Read_(system_call)">https://en.wikipedia.org/wiki/Read_(system_call)</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ¬©
    
      2021 -
    
    2023
     ForensicXlab 
    ¬∑
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js" integrity="sha256-I2BJOV3DaC&#43;ycZZAhylY4S8fJAZ7sJwyeyM&#43;YpDH7aw="></script>
  

  

  

  

  

  

  

  

  

  
</body>

</html>
