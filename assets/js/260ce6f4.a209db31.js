"use strict";(self.webpackChunkexhume=self.webpackChunkexhume||[]).push([[755],{3240:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/generated-82fef2e4c5e12f960eae0c800e813ae8.png"},6407:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/screenshot-75c4f63527ba5ef1f03f9f97d7ce64cc.png"},7703:e=>{e.exports=JSON.parse('{"permalink":"/blog/macisf","source":"@site/blog/2022-03-22-macisf/index.md","title":"\ud83d\udcc4 Volatility3 - ISF for MacOs","description":"Being interested in memory forensic for a while now I have learned a lot about the Volatility framework. This article will introduce volatility3 core components and focus on kernel symbols. Next, I will explain the steps I took to generate a lot of MacOs SymbolTables. Finally you will be able to retrieve those SymbolsTables directly from github. The final goal is to create a public repository like windows to automatically identify mac os system version and directly download the associated SymbolTables.","date":"2022-03-22T00:00:00.000Z","tags":[{"inline":true,"label":"DFIR","permalink":"/blog/tags/dfir"},{"inline":true,"label":"Memory Forensics","permalink":"/blog/tags/memory-forensics"},{"inline":true,"label":"MacOs","permalink":"/blog/tags/mac-os"}],"readingTime":6.665,"hasTruncateMarker":true,"authors":[{"name":"k1nd0ne","title":"Digital Forensics Spiderman","url":"https://github.com/k1n0ne","page":{"permalink":"/blog/authors/k-1-nd-0-ne"},"socials":{"x":"https://x.com/k1nd0ne","github":"https://github.com/k1nd0ne","bluesky":"https://bsky.app/profile/k1nd0ne.bsky.social"},"imageURL":"https://avatars.githubusercontent.com/u/27780432?v=4","key":"k1nd0ne"}],"frontMatter":{"slug":"macisf","title":"\ud83d\udcc4 Volatility3 - ISF for MacOs","authors":["k1nd0ne"],"tags":["DFIR","Memory Forensics","MacOs"]},"unlisted":false,"prevItem":{"title":"\ud83d\udcd8 Using Volatility3 as a library","permalink":"/blog/volaslib"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(6540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}},9713:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var o=n(7703),i=n(4848),r=n(8453);const s={slug:"macisf",title:"\ud83d\udcc4 Volatility3 - ISF for MacOs",authors:["k1nd0ne"],tags:["DFIR","Memory Forensics","MacOs"]},a=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Volatility",id:"volatility",level:2},{value:"Volatility main components",id:"volatility-main-components",level:3},{value:"MacOs Kernel Debug Kit",id:"macos-kernel-debug-kit",level:2},{value:"Automation",id:"automation",level:2}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Being interested in memory forensic for a while now I have learned a lot about the Volatility framework. This article will introduce volatility3 core components and focus on kernel symbols. Next, I will explain the steps I took to generate a lot of MacOs SymbolTables. Finally you will be able to retrieve those SymbolsTables directly from github. The final goal is to create a public repository like windows to automatically identify mac os system version and directly download the associated SymbolTables."}),"\n",(0,i.jsx)(t.h2,{id:"volatility",children:"Volatility"}),"\n",(0,i.jsx)(t.p,{children:"Memory analysis is focusing on the extraction of evidence by exploiting the Random Access Memory (abbreviated to RAM) of a given system. Volaltility is the best state of the art framework to perform digital forensic on RAM after its acquisition. Volatility has become the world\u2019s most widely used memory forensics platform and its python3 version is currently under active development."}),"\n",(0,i.jsx)(t.h3,{id:"volatility-main-components",children:"Volatility main components"}),"\n",(0,i.jsx)(t.p,{children:"When doing memory analysis with Volatility3, the memory is split into three major components :"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Memory Layers"})," : This component allows correct memory mapping and address translation."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Templates and Objects"})," :  A template is the representation of what we know about the structure of the final object we want to extract and explore from the memory layer to perform memory forensic."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Symbol Tables"})," :","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"When a program is compiled, it is aware of its own structures and how they are stored. This means that when doing offline memory analysis, volatility needs to be aware of the context of the program that were executed."}),"\n",(0,i.jsx)(t.li,{children:"When the compilation of a program is performed, debugging symbols are produce alongside it. A symbol can be viewed as an address associated to a template."}),"\n",(0,i.jsx)(t.li,{children:"We can picture the set of debugging symbols produced at compilation being equal to one SymbolTable which is a JSON structure understandable by volatility.  The more SymbolTable volatility possesses the more symbols and templates it can extract from memory."}),"\n",(0,i.jsx)(t.li,{children:"The representation of all of the SymbolTables retrieved by volatility is called the SymbolSpace. The SymbolSpace is stored within the context of the volatility3 framework. When executing volatility3 on a memory dump, it is going to build its context and SymbolSpace from the user's provided SymbolTables."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"As a memory forensics investigator, our goal will be first to extract the debugging symbols generated by the kernel when compiled which will allow us to identify how the system's essential structures are stored in memory. The majority of basic Volatility3 plugging are using the kernel symbols."}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsx)(t.strong,{children:"Windows"})," memory analysis, Volatility is going to build the context using Windows Program Database (PDB) files which are directly fetched from microsoft website and translated into SymbolTables if not already present locally."]}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsx)(t.strong,{children:"Linux"}),", the task is more complicated. Indeed Linux can be declined into a lot of distributions which are all having a different kernel versions which means different SymbolSpace for each version. If you want to perform memory forensic on a random linux you need to extract the kenel debugging symbols of the target which are not always easy to find according to the distribution."]}),"\n",(0,i.jsxs)(t.p,{children:["For ",(0,i.jsx)(t.strong,{children:"Mac"})," the task is similar to Linux, however there is only one single distribution. Mac is tracking the system versions and build numbers. For each system version and build number there is different kernel version therefore potentially different kernel debugging symbols."]}),"\n",(0,i.jsx)(t.p,{children:"The first step to even be able to analyse a memory dump is being able to build the right context. Any incident response team or an investigator would gain a fair amount of time not bothering generating SymbolTables. In the next section we will go deeper on how to generate Intermediate Symbol Format (ISF) file for mac and my journey into the automation of the process for a far amount of mac system versions."}),"\n",(0,i.jsx)(t.h2,{id:"macos-kernel-debug-kit",children:"MacOs Kernel Debug Kit"}),"\n",(0,i.jsx)(t.p,{children:'If you have an Apple account, you can find what Apple calls "Kernel Debug Kits" (KDK). For one specific mac os version and build number, the package contains development & debug versions of the macOS kernel. These files contain full symbolic information, unlike the equivalent files in a normal macOS installation. This is exactly what we need to create our SymbolTables. Mac as well as Linux are using DWARF file to represent the kernel with debugging symbols. The VolatilityFoundation created a go program call dwarf2json to parse the appropriate DWARF files into a JSON ISF file to build the SymbolTables. The Kernel Debugging Kits are available here.'}),"\n",(0,i.jsx)(t.p,{children:"Therefore here are the goals :"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Download all KDK available from Apple's website."}),"\n",(0,i.jsx)(t.li,{children:"Identify the kernel symbols for each version."}),"\n",(0,i.jsx)(t.li,{children:"Generate the ISF files."}),"\n",(0,i.jsx)(t.li,{children:"Share and maintain."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"automation",children:"Automation"}),"\n",(0,i.jsx)(t.p,{children:"The first step was to download all the KDK which are dmg images from Apple's developper website. We can identify that there is 241 available KDK that are covering mac os version 10.4.11_build_8s216 to 12.3_Build_StarESeed21E5212f."}),"\n",(0,i.jsx)(t.p,{children:"I have decided to pick one KDK per major system version to identify the differences in the file structures and where the kernel debugging symbols are located. From there we can begin the script."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:n(6407).A+"",title:"Downloaded ISF",width:"2136",height:"1626"})}),"\n",(0,i.jsx)(t.p,{children:"The major steps are for each KDK :"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Extract the pkg file from the dmg image."}),"\n",(0,i.jsx)(t.li,{children:"Unpack the pkg file."}),"\n",(0,i.jsx)(t.li,{children:"Find the kernel debugging symbols DWARF files."}),"\n",(0,i.jsx)(t.li,{children:"Create the IFS JSON file"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"I chose to use python3 for the implementation :"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'import subprocess\nimport argparse\nimport logging\nimport os, os.path\nimport re\n\ndef find_and_generate_kernel_symbols(dir_path, kernel_version):\n    """Generate the ISF file for the kernel DWARF files found"""\n    cmd = [\'./dwarf2json\', \'mac\']\n    for dirpath, dirnames, files in os.walk(dir_path):\n        for filename in files:\n            if "kernel" == filename or "mach_kernel" == filename:\n                todo = os.path.join(dirpath, filename)\n                cmd.append(\'--macho-symbols\')\n                cmd.append(todo)\n    logger.info(f"Generating volatility ISF for {kernel_version} ")\n    with open("ISF/"+kernel_version[0]+".json", "a") as outfile:\n        try:\n            subprocess.run(cmd, stdout=outfile)\n        except:\n            logger.error(f\'Could not generate ISF for {todo}\')\n    try:\n        subprocess.check_output([\'tar\', \'-cJf\', "ISF/"+kernel_version[0]+".json.xz", "ISF/"+kernel_version[0]+".json" ])\n    except:\n        logger.error(f\'Could not compress ISF into an xz archive\')\n\ndef dir_path(string):\n    """Check if the directory passed is indeed a directory"""\n    if os.path.isdir(string):\n        return string\n    else:\n        raise NotADirectoryError(string)\n\nif __name__ == \'__main__\':\n    parser = argparse.ArgumentParser(description = "Generate all volatility symbole files for the different macOs versions")\n    parser.add_argument(\'--path\', type=dir_path)\n\n    """init"""\n    args = parser.parse_args()\n    logging.basicConfig(level=logging.INFO)\n    logger = logging.getLogger(__name__)\n    logger.info(\'Started\')\n    src_dir = args.path\n    reg_exp = r\'[k|K]ern[e|a]l_[d|D]ebug_[K|k]it_(.*)\\.dmg\'\n\n    """routine"""\n    for dmg_image in os.listdir(src_dir):\n        if "DS_Store" in dmg_image:\n            continue\n        kernel_version = re.findall(reg_exp, dmg_image)\n        logger.info(f\'Kernel version : {kernel_version} \')\n        logger.info(f\'Extracting {dmg_image}\')\n        try:\n            subprocess.check_output([\'7z\', \'x\', src_dir+"/"+dmg_image])\n        except subprocess.CalledProcessError as err:\n            logger.error(f\'Could not extract pkg from : {dmg_image} : {err}\')\n            continue\n        try:\n            kernel_debug_kit_path = dir_path("KernelDebugKit")\n            find_and_generate_kernel_symbols(kernel_debug_kit_path, kernel_version)\n        except NotADirectoryError:\n            pass\n            try:\n                kernel_debug_kit_path = dir_path("Kernel Debug Kit")\n                logger.info(f\'Extracting pkg...\')\n                try:\n                    subprocess.check_output([\'pkgutil\', \'--expand-full\', kernel_debug_kit_path+"/KernelDebugKit.pkg", "KernelDebugKit"])\n                    subprocess.check_output([\'rm\', \'-rf\', kernel_debug_kit_path])\n                    kernel_debug_kit_path = "KernelDebugKit"\n                    find_and_generate_kernel_symbols(kernel_debug_kit_path, kernel_version)\n                except subprocess.CalledProcessError as err:\n                    logger.error(f\'Could not extract pkg from : {kernel_debug_kit_path} : {err}\')\n                    pass\n\n            except NotADirectoryError:\n                logger.error(f\'Could not find the KernelDebugKit directory for {dmg_image}\')\n                pass\n        os.system("rm -rf KernelDebugKit")\n'})}),"\n",(0,i.jsx)(t.p,{children:'This script is using the compiled version of dwarf2json located alongside the script. Once this code is executed on the directory containing all the dmg images, the ISF files are extracted from the multiple kernel debug symbols into a ".xz" archive.'}),"\n",(0,i.jsx)(t.p,{children:"This archive type is understandable by volatility3 when building the context."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:n(3240).A+"",title:"Result",width:"1652",height:"772"})}),"\n",(0,i.jsx)(t.p,{children:"To conclude, I have learned a lot on how volatility3 works while trying to extract kernel symbols from the apple's KDKs. The next steps is to test those symbols and integrate them to VolWeb. Mac memory forensic is also for me a good way to participate to the creation of modules for volatility3."}),"\n",(0,i.jsx)(t.p,{children:"This article and the code may evolve with time if new discoveries are made. The community is invited to test those symbols on memory dumps. In a future blog post, I will focus on the existing ways to dump memory on a modern mac system and try to provide an automated tool or a new way to perfom this task."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsxs)(t.p,{children:["This blog post is written from my own understanding of memory forensic. Don't hesitate to reach me at ",(0,i.jsx)(t.a,{href:"mailto:felix.guyard@forensicxlab.com",children:"felix.guyard@forensicxlab.com"})," and share your suggestions to make this article more complete."]}),"\n"]})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);