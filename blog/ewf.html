<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">üî¶ Debunking the Expert Witness Compression Format (EWF) | Forensicxlab</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://forensicxlab.github.io/blog/ewf"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="üî¶ Debunking the Expert Witness Compression Format (EWF) | Forensicxlab"><meta data-rh="true" name="description" content="As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data."><meta data-rh="true" property="og:description" content="As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-05-11T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/k1n0ne"><meta data-rh="true" property="article:tag" content="EWF,Digital Forensics"><link data-rh="true" rel="canonical" href="https://forensicxlab.github.io/blog/ewf"><link data-rh="true" rel="alternate" href="https://forensicxlab.github.io/blog/ewf" hreflang="en"><link data-rh="true" rel="alternate" href="https://forensicxlab.github.io/blog/ewf" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://forensicxlab.github.io/blog/ewf","mainEntityOfPage":"https://forensicxlab.github.io/blog/ewf","url":"https://forensicxlab.github.io/blog/ewf","headline":"üî¶ Debunking the Expert Witness Compression Format (EWF)","name":"üî¶ Debunking the Expert Witness Compression Format (EWF)","description":"As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data.","datePublished":"2023-05-11T00:00:00.000Z","author":{"@type":"Person","name":"k1nd0ne","description":"Digital Forensics Spiderman","url":"https://github.com/k1n0ne","image":"https://avatars.githubusercontent.com/u/27780432?v=4"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://forensicxlab.github.io/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Forensicxlab RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Forensicxlab Atom Feed"><link rel="stylesheet" href="/assets/css/styles.98b055e0.css">
<script src="/assets/js/runtime~main.314b521f.js" defer="defer"></script>
<script src="/assets/js/main.ae339742.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/img/logo.svg"><link rel="preload" as="image" href="https://avatars.githubusercontent.com/u/27780432?v=4"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="ForensicXlab Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="ForensicXlab Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/thanatology">Thanatology</a><a class="navbar__item navbar__link" href="/docs/exhume">Exhume</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a href="https://github.com/forensicxlab" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://discord.gg/AqkYgR5HEg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/voliat">üì¶ Volatility3 : Import Address Table</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/volads">üì¶ Volatility3 : Alternate Data Stream Scan</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/hibernation">üìò Volatility3: Modern Windows Hibernation file analysis</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/vols3">üìò Volatility3 - Remote analysis on cloud object-storage.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/steam">üî¶ Video Games Forensics - Steam</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/keepass">üì¶ Volatility3 Windows Plugin - KeePass</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/slug">Title</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/ewf">üî¶ Debunking the Expert Witness Compression Format (EWF)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/vision">üß¨ Malware Analysis with VISION-ProcMon</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2022</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/anydesk">üì¶ Volatility3 Windows Plugin - AnyDesk</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/inodes">üì¶ Volatility3 Linux Plugin - Inodes</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/prefetch">üì¶ Volatility3 Windows Plugin - Prefetch</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/cb-brave">üñã Cyberdefenders - Writeup - Brave</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/volaslib">üìò Using Volatility3 as a library</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/macisf">üìÑ Volatility3 - ISF for MacOs</a></li></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_f1Hy">üî¶ Debunking the Expert Witness Compression Format (EWF)</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-05-11T00:00:00.000Z">May 11, 2023</time> ¬∑ <!-- -->11 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a class="avatar__photo-link" href="/blog/authors/k-1-nd-0-ne"><img class="avatar__photo authorImage_XqGP" src="https://avatars.githubusercontent.com/u/27780432?v=4" alt="k1nd0ne"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="/blog/authors/k-1-nd-0-ne"><span class="authorName_yefp">k1nd0ne</span></a></div><small class="authorTitle_nd0D" title="Digital Forensics Spiderman">Digital Forensics Spiderman</small><div class="authorSocials_rSDt"><a href="https://x.com/k1nd0ne" target="_blank" rel="noopener noreferrer" class="authorSocialLink_owbf" title="X"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" fill="none" viewBox="0 0 1200 1227" style="--dark:#000;--light:#fff" class="authorSocialLink_owbf xSvg_y3PF"><path d="M714.163 519.284 1160.89 0h-105.86L667.137 450.887 357.328 0H0l468.492 681.821L0 1226.37h105.866l409.625-476.152 327.181 476.152H1200L714.137 519.284h.026ZM569.165 687.828l-47.468-67.894-377.686-540.24h162.604l304.797 435.991 47.468 67.894 396.2 566.721H892.476L569.165 687.854v-.026Z"></path></svg></a><a href="https://github.com/k1nd0ne" target="_blank" rel="noopener noreferrer" class="authorSocialLink_owbf" title="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 256 250" preserveAspectRatio="xMidYMid" style="--dark:#000;--light:#fff" class="authorSocialLink_owbf githubSvg_Uu4N"><path d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46 6.397 1.185 8.746-2.777 8.746-6.158 0-3.052-.12-13.135-.174-23.83-35.61 7.742-43.124-15.103-43.124-15.103-5.823-14.795-14.213-18.73-14.213-18.73-11.613-7.944.876-7.78.876-7.78 12.853.902 19.621 13.19 19.621 13.19 11.417 19.568 29.945 13.911 37.249 10.64 1.149-8.272 4.466-13.92 8.127-17.116-28.431-3.236-58.318-14.212-58.318-63.258 0-13.975 5-25.394 13.188-34.358-1.329-3.224-5.71-16.242 1.24-33.874 0 0 10.749-3.44 35.21 13.121 10.21-2.836 21.16-4.258 32.038-4.307 10.878.049 21.837 1.47 32.066 4.307 24.431-16.56 35.165-13.12 35.165-13.12 6.967 17.63 2.584 30.65 1.255 33.873 8.207 8.964 13.173 20.383 13.173 34.358 0 49.163-29.944 59.988-58.447 63.157 4.591 3.972 8.682 11.762 8.682 23.704 0 17.126-.148 30.91-.148 35.126 0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002 256 57.307 198.691 0 128.001 0Zm-80.06 182.34c-.282.636-1.283.827-2.194.39-.929-.417-1.45-1.284-1.15-1.922.276-.655 1.279-.838 2.205-.399.93.418 1.46 1.293 1.139 1.931Zm6.296 5.618c-.61.566-1.804.303-2.614-.591-.837-.892-.994-2.086-.375-2.66.63-.566 1.787-.301 2.626.591.838.903 1 2.088.363 2.66Zm4.32 7.188c-.785.545-2.067.034-2.86-1.104-.784-1.138-.784-2.503.017-3.05.795-.547 2.058-.055 2.861 1.075.782 1.157.782 2.522-.019 3.08Zm7.304 8.325c-.701.774-2.196.566-3.29-.49-1.119-1.032-1.43-2.496-.726-3.27.71-.776 2.213-.558 3.315.49 1.11 1.03 1.45 2.505.701 3.27Zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033-1.448-.439-2.395-1.613-2.103-2.626.301-1.01 1.747-1.484 3.207-1.028 1.446.436 2.396 1.602 2.095 2.622Zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95-1.53.034-2.769-.82-2.786-1.86 0-1.065 1.202-1.932 2.733-1.958 1.522-.03 2.768.818 2.768 1.868Zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37-1.485.271-2.861-.365-3.05-1.386-.184-1.056.893-2.114 2.376-2.387 1.514-.263 2.868.356 3.061 1.403Z"></path></svg></a></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>As a digital forensic expert, proving the authenticity and reliability of a forensic image in court is essential. Indeed, the integrity of the data needs to be maintained during the imaging process, preventing any accidental or intentional modification of the data.
The Expert Witness Compression Format (EWF) provides a way to store metadata about the image, such as the source device, imaging tool, checksums, signatures, and other relevant information about the acquired media. This imaging format main feature is its compression capability thus reducing the size of the resulting image file. Compression allows for faster analysis of the data and reduces storage requirements.
This article is meant to vulgarize the structures behind an EWF Segment. The reader will discover the main algorithms to use in order to be able to read and seek inside such image format. Finally, a proof of concept writen in rust will be shared to the reader.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="filesystem-layers-of-abstraction">Filesystem layers of abstraction<a href="#filesystem-layers-of-abstraction" class="hash-link" aria-label="Direct link to Filesystem layers of abstraction" title="Direct link to Filesystem layers of abstraction">‚Äã</a></h2>
<p>Before getting right into the main subject of this article, it is important to learn or get a little reminder about the filesystem concepts, vocabulary, and the underlying layers of abstractions.
Let us take the Unix filesystem concept as an example. Below is a vulgarized representation of the main layers of abstraction.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/1-7a939b608e6c8f0b9b010d3f93415301.png" title="Filesystem layout" width="1198" height="721" class="img_ev3q"></p>
<p>A storage medium (hard drive, SSD, ‚Ä¶) have the necessary set of electronics to create an abstraction of the Logical Block Addressing. It can be viewed as contiguous sequence of sectors. A sector is the smallest accessible unit on a drive (typically 512 bytes for disk drives).  It is possible to create a group multiple sectors and form a block.  Blocks are the smallest accessible units on a filesystem.  Each filesystem type can have their own concepts to represents files, directories, hardware devices etc...
The exploitation system is supplying the abstraction of those human friendly concepts via the kernel to perform various actions on the filesystem (read, write, seek...).</p>
<p>Digital forensics is performed on a copy of the media to be investigated. This can be done with various tools (FTK Imager, EnCase, dd, Falcon, others‚Ä¶) and produce an image that can have various format (raw, img, ewf, vmdk, vdi‚Ä¶) to be analyzed later without performing the investigation on the original media.</p>
<p>From a forensics perspective, when a storage media is acquired, the investigator needs to find a way to emulate all the necessary abstraction layers in order to extract specific artifacts usefull to an investigation without tempering with the data. Forensics tools are providing such abstraction and capabilities. Most of those tools support different image format. One of these formats is well known and largely used: the Expert Witness Compressing Format (EWF).</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/2-f5aa868db1de4b2b4395bdc65c95f35b.png" title="Filesystem abstraction" width="1878" height="1338" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-expert-witness-compression-format">The Expert Witness Compression Format<a href="#the-expert-witness-compression-format" class="hash-link" aria-label="Direct link to The Expert Witness Compression Format" title="Direct link to The Expert Witness Compression Format">‚Äã</a></h2>
<p>The Expert Witness Compression Format (EWF) is a forensic image output format created by the ASRDATA company. It can be used to create a bit-by-bit copy of a digital device. It includes both data and metadata, such as the partition table and other information about the device. EWF is designed to maintain the integrity of the original data and can be compressed to reduce storage requirements. It is widely used to preserve evidence for analysis and investigation both by law enforcement, digital forensics and incident response companies. This format is not so easy to understand because it is a proprietary file format, thus the purpose of this blog article. Luckily, the opensource community provide a C library and a nice documentation about this file format <sup><a href="#user-content-fn-1-ff8942" id="user-content-fnref-1-ff8942" data-footnote-ref="true" aria-describedby="footnote-label">1</a></sup>. Let‚Äôs try to have a nice mental representation of the components of an EWF image.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-segments">The segments<a href="#the-segments" class="hash-link" aria-label="Direct link to The segments" title="Direct link to The segments">‚Äã</a></h3>
<p>An EWF image can be divided into multiple segment files (there can also be a unique segment file). Those segments files have a consecutive extension system: Starting from ‚ÄúE01‚Äù to ‚ÄúE99‚Äù, then in alphabetical order from ‚ÄúEAA‚Äù to ‚ÄúZZZ‚Äù. Dividing a large sized media evidence source into multiple segments is a great way to prevent a large and unique raw output file that can sometime creates problems on some filesystem. Each segment file is composed of a <strong>Header</strong> and multiple <strong>Sections</strong>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="the-ewf-file-header-and-sections">The EWF file Header and Sections<a href="#the-ewf-file-header-and-sections" class="hash-link" aria-label="Direct link to The EWF file Header and Sections" title="Direct link to The EWF file Header and Sections">‚Äã</a></h4>
<p>Let‚Äôs now dive into the components of a EWF segment file.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/3-a08894ef23d4821517f6987ecdfe9c8f.png" title="EWF structure" width="1490" height="843" class="img_ev3q"></p>
<p>The EWF is storing the source evidence image‚Äôs sectors inside <strong>chunks</strong>. A chunk is just a group of sectors. There is a finite number of chunks per segments. Therefore, the information about the sectors and chunks needs to be known if we want to read them.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="the-segment-file-header">The segment file Header<a href="#the-segment-file-header" class="hash-link" aria-label="Direct link to The segment file Header" title="Direct link to The segment file Header">‚Äã</a></h4>
<p>Each segment file has a <strong>Header</strong> (do not confuse the <strong>segment file header</strong> with the <strong>section header</strong> described later). The file header contains a signature (or a magic number) of 8 bytes that attest of its format:</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/4-8f3978b8f737aaa54a501a75624be5a3.png" title="Header" width="1108" height="636" class="img_ev3q"></p>
<p>In this example, the signature is: ‚ÄúEVF\0x09\0x0d\0x0a\0xff\0x00‚Äù</p>
<p>The file header also contains the information about the <strong>first section offset</strong> and the segment number.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="the-sections">The sections<a href="#the-sections" class="hash-link" aria-label="Direct link to The sections" title="Direct link to The sections">‚Äã</a></h4>
<p>The sections are the metadata of the image used by the tools to be able to read the evidence sectors and get other various information about the acquired evidence (checksums, acquisition tool used, timestamps etc‚Ä¶). Each section starts with metadata describing itself:</p>
<ul>
<li>Its type (header, volume, ‚Ä¶)</li>
<li>Its size</li>
<li>The next section offset</li>
</ul>
<p>Here is what important information you can extract from each section:</p>
<ul>
<li><strong>The header section -</strong> Not to be confused with the segment file header described earlier, it contains information about the acquired media (case number, Evidence Number, Examiner name, etc.). Each acquisition tools have their own way of describing what information reside in this section.</li>
<li><strong>The ‚Äúvolume‚Äù or ‚Äúdisk‚Äù section ‚Äì</strong> It contains critical information about the sectors and the chunks of the acquired media that will help the investigator to parse the EWF file like the chunk count, the size of a chunk, the size of a sector, the number of sectors per chunk.</li>
<li><strong>The sector section ‚Äì</strong> It contains the actual chunks of the acquired evidence. Now, the main advantage about EWF is that some of the chunks can be compressed to gain space on the destination storage using the zlib compression algorithm. Therefore, we need to know what the offsets of each chunk are and if it is compressed chunk or not.</li>
<li><strong>The table section ‚Äì</strong> This section is like a table of pointers that will tell the investigator where to find each chunk and if it is compressed. The most significant bit (MSB) of each pointer indicates if the chunk is compressed (1) or uncompressed (0).</li>
<li><strong>The ‚Äúend‚Äù or ‚Äúnext‚Äù section ‚Äì</strong> The ‚Äúend‚Äú section indicates that this segment file was the last one. However, the ‚Äúnext‚Äù section indicates that there is another segment to parse.</li>
</ul>
<p>You can now understand better the image showed at the beginning. To have more details about each section, the libewf project is providing a good documentation <sup><a href="#user-content-fn-2-ff8942" id="user-content-fnref-2-ff8942" data-footnote-ref="true" aria-describedby="footnote-label">2</a></sup>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="parsing-the-ewf-segments">Parsing the EWF Segments<a href="#parsing-the-ewf-segments" class="hash-link" aria-label="Direct link to Parsing the EWF Segments" title="Direct link to Parsing the EWF Segments">‚Äã</a></h3>
<p>Now that you have a better understanding of this file format, you want to be able to write a code to create the abstraction layer needed to read data like a standard disk and beginning the extraction of evidence.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="step-1-parsing-all-the-useful-metadata-from-each-segment">Step 1: Parsing all the useful metadata from each segment.<a href="#step-1-parsing-all-the-useful-metadata-from-each-segment" class="hash-link" aria-label="Direct link to Step 1: Parsing all the useful metadata from each segment." title="Direct link to Step 1: Parsing all the useful metadata from each segment.">‚Äã</a></h4>
<p>First, we want to be able to read chunks, we first need to extract all the necessary metadata about those chunks from each segment. To hold all the important metadata, we can create multiple structures to store them. Here is an example of what you can do.</p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/5-92d8558c343bb21817ff54253852bcf9.png" title="EWF structure" width="1421" height="896" class="img_ev3q"></p>
<p>Here, the purple color corresponds to a Structure or an Object. The red color represents an HashMap or a Dictionary with a key and a value. The blue color is a vector. You‚Äôll notice that we have created the structures representing the different headers and sections of an EWF Segment. Our main goal is:</p>
<ul>
<li>To know where all the segment file descriptors are. (segments)</li>
<li>To store all the chunk for each segment (chunks).</li>
<li>To store all the end of sector offset for each segment (end_of_sectors).</li>
<li>To know what is the current chunk that the EWF structure points to (CachedChunk).
To understand better here are the structure definitions of a Chunk and a CachedChunk:</li>
</ul>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/6-454e2ad92c136e89a30f63e22005df0b.png" title="Chunk structure" width="1094" height="686" class="img_ev3q"></p>
<p>To parse a segment here is a pseudo-code algorithm:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Algorithm: parse_segment</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Parameters: self: The EWF Structure, file: the current segment.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Return value: EwfSegment filled with all the information about the chunks</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Begin:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">		// Parsing EWF Header</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    self.ewf_header &lt;- new EwfHeader(file)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    current_offset &lt;- 0xd // We place our self just after the EWFHeader.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ewf_section_descriptor_size &lt;- 0x4c</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    extracted_chunks &lt;- []</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    begin loop:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Parsing EWF section descriptor</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        section &lt;- new EwfSectionDescriptor(file, current_offset)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        section_offset &lt;- section.next_section_offset</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        section_size &lt;- section.section_size</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        section_type &lt;- section.section_type_def</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        self.sections.push(section) // Save the section into a vector</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Saving header information</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if section_type == &quot;header&quot; or section_type == &quot;header2&quot;:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            self.header &lt;- new EwfHeaderSection(file, current_offset+ewf_section_descriptor_size, self.sections.last())</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Saving volume information</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if section_type == &quot;disk&quot; or section_type == &quot;volume&quot;:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            self.volume &lt;- new EwfVolumeSection(file, current_offset+ewf_section_descriptor_size)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Extracting chunks from table section</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if section_type == &quot;table&quot;:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            extracted_chunks.extend(self.parse_table(&amp;file, current_offset+ewf_section_descriptor_size)) //We save our chunks structure.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Saving end of sectors information</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if section_type == &quot;sectors&quot;:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            self.end_of_sectors.insert(self.ewf_header.segment_number, current_offset + section_size)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Checking if the current section is done</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if current_offset == section_offset or section_type == &quot;done&quot;:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            break</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // Updating the offset to go throught the segment file.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        current_offset &lt;- section_offset</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    end loop</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // Saving segment and extracted chunks information</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    self.segments.push(file)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    self.chunks.insert(self.ewf_header.segment_number, extracted_chunks)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return self</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">End</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Notice that this function is calling other parsing functions and data structures that I did not describe in pseudo-code. The main goal is to understand the main parsing routine.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="step-2-read-an-arbitrary-chunk">Step 2: Read an arbitrary chunk.<a href="#step-2-read-an-arbitrary-chunk" class="hash-link" aria-label="Direct link to Step 2: Read an arbitrary chunk." title="Direct link to Step 2: Read an arbitrary chunk.">‚Äã</a></h4>
<p>Now that we have save all our chunks, we can create a function to read the chunk number <strong>X</strong> from the given segment number <strong>Y</strong>.</p>
<p>Reading a chunk includes checking if it is a compressed chunk. And if so, decompressing its data before.</p>
<ol>
<li>To read the data from a chunk number in a segment file here are the steps to follow :</li>
<li>Check if the given chunk number is valid for the given segment using the ‚Äúchunks‚Äù dictionary in our EWF structure. If not, it raises an error.</li>
<li>Use the following variables:</li>
</ol>
<ul>
<li>data: An empty buffer of bytes to store the read data.</li>
<li>chunk: A reference to the chunk object in the segment.</li>
<li>start_offset: The starting position in the segment where the chunk data is located.</li>
<li>end_offset: The ending position in the segment where the chunk data is located (for compressed chunks).</li>
</ul>
<ol start="4">
<li>Seek to the starting position of the chunk data in the segment.</li>
<li>If the chunk is not compressed, read data from the segment into a buffer.</li>
<li>If the chunk is compressed, decode the compressed data using Zlib <sup><a href="#user-content-fn-4-ff8942" id="user-content-fnref-4-ff8942" data-footnote-ref="true" aria-describedby="footnote-label">3</a></sup> and store the result in the data buffer.</li>
<li>Return the data buffer containing the chunk data.</li>
</ol>
<p>We can now read the data from any chunk number in a given segment!</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="step-3-create-a-standard-read">Step 3: Create a standard read<a href="#step-3-create-a-standard-read" class="hash-link" aria-label="Direct link to Step 3: Create a standard read" title="Direct link to Step 3: Create a standard read">‚Äã</a></h4>
<p>Now the last step is to create a read function to imitate the traditional read system call <sup><a href="#user-content-fn-3-ff8942" id="user-content-fnref-3-ff8942" data-footnote-ref="true" aria-describedby="footnote-label">4</a></sup> on a POSIX system. To perform this task here are the steps for a given number of bytes to read:</p>
<ol>
<li>Check if there is any cached chunk data available. If not, read the first chunk of the first segment and set it as the cached chunk data.</li>
<li>Loop until the size is zero.</li>
<li>If the remaining size of the data to be read is less than or equal to the remaining data in the cached chunk, update the buffer with the remaining data. Then update the cached chunk pointer and size.</li>
<li>If the remaining size is greater than the remaining cached chunk data, update the buffer with all the remaining cached chunk data and calculate the remaining size of the data to be read.</li>
<li>Check if there are more chunks to be read or if the end of the segments has been reached. If there are more chunks, get the next chunk number and read that chunk&#x27;s data.</li>
<li>Otherwise, return the buffer that has been read so far (nothing more to read).</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="proof-of-concept">Proof of concept<a href="#proof-of-concept" class="hash-link" aria-label="Direct link to Proof of concept" title="Direct link to Proof of concept">‚Äã</a></h2>
<p>Now that we have finished the theorical part, I am sharing to you a proof of concept written in rust. The code can be found here: <a href="https://github.com/forensicxlab/EWF" target="_blank" rel="noopener noreferrer">https://github.com/forensicxlab/EWF</a></p>
<p><img decoding="async" loading="lazy" alt="alt text" src="/assets/images/8-195c0769fda1a529bb0a81405c89676a.png" title="POC" width="1034" height="464" class="img_ev3q"></p>
<p>This code will show you all the important metadata about the parsed segments. It is capable of:</p>
<ul>
<li>Reading and seeking through the sectors of an EWF image.</li>
<li>Parsing the MBR.</li>
<li>Calculate the original media signature (MD5 of all the sectors).</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">‚Äã</a></h2>
<p>To conclude this blogpost, we were able to create the abstraction layer needed to read an EWF image. We can now identify partitions and create other abstraction layer to read files, reconstruct a system tree etc‚Ä¶ This can be the subject of future blogposts. Do not hesitate to reach me at <a href="mailto:felix.guyard@forensicxlab.com" target="_blank" rel="noopener noreferrer">felix.guyard@forensicxlab.com</a> to make this article better.</p>
<!-- -->
<section data-footnotes="true" class="footnotes"><h2 class="anchor anchorWithStickyNavbar_LWe7 sr-only" id="footnote-label">Footnotes<a href="#footnote-label" class="hash-link" aria-label="Direct link to Footnotes" title="Direct link to Footnotes">‚Äã</a></h2>
<ol>
<li id="user-content-fn-1-ff8942">
<p><a href="https://github.com/libyal/libewf/blob/main/documentation/Expert%20Witness%20Compression%20Format%20(EWF).asciidoc" target="_blank" rel="noopener noreferrer">https://github.com/libyal/libewf/blob/main/documentation/Expert%20Witness%20Compression%20Format%20(EWF).asciidoc</a> <a href="#user-content-fnref-1-ff8942" data-footnote-backref="" aria-label="Back to reference 1" class="data-footnote-backref">‚Ü©</a></p>
</li>
<li id="user-content-fn-2-ff8942">
<p><a href="https://github.com/libyal/libewf" target="_blank" rel="noopener noreferrer">https://github.com/libyal/libewf</a> <a href="#user-content-fnref-2-ff8942" data-footnote-backref="" aria-label="Back to reference 2" class="data-footnote-backref">‚Ü©</a></p>
</li>
<li id="user-content-fn-4-ff8942">
<p><a href="https://www.zlib.net/" target="_blank" rel="noopener noreferrer">https://www.zlib.net/</a> <a href="#user-content-fnref-4-ff8942" data-footnote-backref="" aria-label="Back to reference 3" class="data-footnote-backref">‚Ü©</a></p>
</li>
<li id="user-content-fn-3-ff8942">
<p><a href="https://en.wikipedia.org/wiki/Read_(system_call)" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/Read_(system_call)</a> <a href="#user-content-fnref-3-ff8942" data-footnote-backref="" aria-label="Back to reference 4" class="data-footnote-backref">‚Ü©</a></p>
</li>
</ol>
</section></div><footer class="docusaurus-mt-lg"><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/ewf">EWF</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/digital-forensics">Digital Forensics</a></li></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/slug"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">Title</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/vision"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">üß¨ Malware Analysis with VISION-ProcMon</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#filesystem-layers-of-abstraction" class="table-of-contents__link toc-highlight">Filesystem layers of abstraction</a></li><li><a href="#the-expert-witness-compression-format" class="table-of-contents__link toc-highlight">The Expert Witness Compression Format</a><ul><li><a href="#the-segments" class="table-of-contents__link toc-highlight">The segments</a></li><li><a href="#parsing-the-ewf-segments" class="table-of-contents__link toc-highlight">Parsing the EWF Segments</a></li></ul></li><li><a href="#proof-of-concept" class="table-of-contents__link toc-highlight">Proof of concept</a></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2025 Forensicxlab</div></div></div></footer></div>
</body>
</html>