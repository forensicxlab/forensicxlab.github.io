"use strict";(self.webpackChunkexhume=self.webpackChunkexhume||[]).push([[2861],{1157:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/10-62b2680fd46667c67cdd686cd9d62dff.png"},1605:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/5-06fdbf953c2fe41621118d7178caa6f2.png"},2147:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/3-977eec9fd985c1193517ad591d214d4c.png"},2273:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/1-5b240a8c2d7fa5b9121a2f8c0ff47bfd.png"},2288:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/8-fbd628376fd5a2f03acebec5b34b2d75.png"},2823:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/7-c6b2029ad2d4b5b162fc3f405999a79c.png"},3700:e=>{e.exports=JSON.parse('{"permalink":"/blog/cb-brave","source":"@site/blog/2022-07-11-cyberdefenders-brave/index.md","title":"\ud83d\udd8b Cyberdefenders - Writeup - Brave","description":"This writeup is covering the cyberdefenders.org challenge named \\"Brave\\". Today we are going to solve this challenge using the VolWeb memory analysis platform.","date":"2022-07-11T00:00:00.000Z","tags":[{"inline":true,"label":"DFIR","permalink":"/blog/tags/dfir"},{"inline":true,"label":"Memory Forensics","permalink":"/blog/tags/memory-forensics"},{"inline":true,"label":"Cyberdefenders","permalink":"/blog/tags/cyberdefenders"}],"readingTime":4.32,"hasTruncateMarker":true,"authors":[{"name":"k1nd0ne","title":"Digital Forensics Spiderman","url":"https://github.com/k1n0ne","page":{"permalink":"/blog/authors/k-1-nd-0-ne"},"socials":{"x":"https://x.com/k1nd0ne","github":"https://github.com/k1nd0ne"},"imageURL":"https://avatars.githubusercontent.com/u/27780432?v=4","key":"k1nd0ne"}],"frontMatter":{"slug":"cb-brave","title":"\ud83d\udd8b Cyberdefenders - Writeup - Brave","authors":["k1nd0ne"],"tags":["DFIR","Memory Forensics","Cyberdefenders"]},"unlisted":false,"prevItem":{"title":"\ud83d\udce6 Volatility3 Windows Plugin - Prefetch","permalink":"/blog/prefetch"},"nextItem":{"title":"\ud83d\udcd8 Using Volatility3 as a library","permalink":"/blog/volaslib"}}')},5703:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>n,toc:()=>h});var n=s(3700),i=s(4848),a=s(8453);const o={slug:"cb-brave",title:"\ud83d\udd8b Cyberdefenders - Writeup - Brave",authors:["k1nd0ne"],tags:["DFIR","Memory Forensics","Cyberdefenders"]},r=void 0,l={authorsImageUrls:[void 0]},h=[{value:"Scenario",id:"scenario",level:2},{value:"Analysis creation",id:"analysis-creation",level:2},{value:"Process Analysis",id:"process-analysis",level:2},{value:"Network analysis",id:"network-analysis",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const t={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:'This writeup is covering the cyberdefenders.org challenge named "Brave". Today we are going to solve this challenge using the VolWeb memory analysis platform.'}),"\n",(0,i.jsx)(t.h2,{id:"scenario",children:"Scenario"}),"\n",(0,i.jsx)(t.p,{children:"A memory image was taken from a seized Windows machine. Analyze the image and answer the provided questions."}),"\n",(0,i.jsx)(t.h2,{id:"analysis-creation",children:"Analysis creation"}),"\n",(0,i.jsx)(t.p,{children:'After firing up your instance of VolWeb, login to the platform, create a new Windows investigation and upload the challenge memory image. Once the image is uploaded, launch the analysis from the "Analysis" menu. Next, select the analysis and click on the "Review results" button.'}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(2273).A+"",title:"Analysis Creation",width:"1283",height:"676"})}),"\n",(0,i.jsxs)(t.p,{children:['From there, we can start our investigation on the memory image using the left panel (clicking on the "Plugins" button). From the displayed menu named "Case", we have the information we need to answer question ',(0,i.jsx)(t.strong,{children:"#2"})," about the SHA256 value of the RAM image which is : ",(0,i.jsx)(t.strong,{children:"9db01b1e7b19a3b2113bfb65e860fffd7a1630bdf2b18613d206ebf2aa0ea172"})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(8826).A+"",title:"Analysis Hash",width:"710",height:"85"})}),"\n",(0,i.jsx)(t.h2,{id:"process-analysis",children:"Process Analysis"}),"\n",(0,i.jsxs)(t.p,{children:['Let\'s try to find what tool were used to dump the memory of this machine and at the same time, identify the PID of "brave.exe" to answer question ',(0,i.jsx)(t.strong,{children:"#1"})," & ",(0,i.jsx)(t.strong,{children:"#3"}),". For this we are going to go through the process tree graph."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"alt text",src:s(6938).A+"",title:"PSTree",width:"970",height:"464"}),"\n",(0,i.jsx)(t.img,{alt:"alt text",src:s(2147).A+"",title:"PSTree",width:"958",height:"751"})]}),"\n",(0,i.jsxs)(t.p,{children:["Using this plugin, we immediately have the process ID of brave.exe which is 4856 and thus, is the answer for question ",(0,i.jsx)(t.strong,{children:"#3"}),'. If we look deeper into the tree we can also spot "FTK Imager" which is a known forensic tool that can be used to dump memory from a live system.']}),"\n",(0,i.jsxs)(t.p,{children:["To answer question ",(0,i.jsx)(t.strong,{children:"#1"}),", we need to find the time at which the RAM image was fully acquired. For this, I like to use the timeline plugin. It's always good to take a look at the timeline to take a step back and have a good view of the activities registered on the machine in time. We can try to identify the time at which the memory dump was finished by looking for the FTK Imager activities. We know that when the dumping procedure is finished, we have no more information registered, which means we need to identify the last event timestamp recorded."]}),"\n",(0,i.jsx)(t.p,{children:"Looking at the timeline, we find the following :"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(8540).A+"",title:"PSTree",width:"1743",height:"323"})}),"\n",(0,i.jsxs)(t.p,{children:["This timestamp ",(0,i.jsx)(t.strong,{children:"2021-04-30 17:52:18"}),' is the latest identified. By looking at the cyberdefenders challenge, we know that the last digit of the answer is "19" which is one second greater than our result. The answer for question ',(0,i.jsx)(t.strong,{children:"#1"})," is indeed 2021-04-30 17:52:19."]}),"\n",(0,i.jsx)(t.h2,{id:"network-analysis",children:"Network analysis"}),"\n",(0,i.jsxs)(t.p,{children:['To answer question #4, we can use the netscan and the netstat plugin. By using the search bar, we can look for the key word "ESTABLISHED" and count how many connections are identified : For this question, the "netstat" plugin is returning 10 connections marked as ESTABLISHED, and only 9 connections for the "netscan" plugin. The answer for question ',(0,i.jsx)(t.strong,{children:"#4"})," is indeed ",(0,i.jsx)(t.strong,{children:"10"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(1605).A+"",title:"PSTree",width:"1445",height:"620"})}),"\n",(0,i.jsx)(t.p,{children:"For the next question, we are looking for a FQDN that the chrome process established a connection with. By looking at the IP contacted by the chrome processes, we can extract some public IP addresses."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(9806).A+"",title:"PSTree",width:"605",height:"385"})}),"\n",(0,i.jsxs)(t.p,{children:["Using the tool of your choice, you can search for the FQDN linked to IP addresses we have found. To conclude, the domain is ",(0,i.jsx)(t.strong,{children:"protonmail.ch"}),", which is the right answer for question ",(0,i.jsx)(t.strong,{children:"#5"}),"."]}),"\n",(0,i.jsx)(t.p,{children:'The next question is asking us the MD5 hash value of process memory for PID 6988. For this one, we are going to look for the process using the "Process" tab and look at the left panel to dump our process and calculate the signature.'}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"alt text",src:s(2823).A+"",title:"PSTree",width:"285",height:"243"}),"\n",(0,i.jsx)(t.img,{alt:"alt text",src:s(8068).A+"",title:"PSTree",width:"1242",height:"43"})]}),"\n",(0,i.jsxs)(t.p,{children:["Then answer for question ",(0,i.jsx)(t.strong,{children:"#6"})," is indeed ",(0,i.jsx)(t.strong,{children:"0b493d8e26f03ccd2060e0be85f430af"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"For the next question we need to go fetch the word starting at offset 0x45BE876 with a length of 6 bytes in the memory dump. We can write a simple python3 script to do this."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'import sys\nwith open(sys.argv[1],"rb") as process:\n   process.seek(0x45BE876)\n   word = process.read(6)\n   print(word)\n'})}),"\n",(0,i.jsx)(t.p,{children:"OUTPUT :"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"~/work/DFIR/Cyberdefender/c49-AfricanFalls2 \xbb python3 extract.py 20210430-Win10Home-20H2-64bit-memdump.mem                                                                                                           k1nd0ne@MacBook-Pro-de-Felix\nb'hacker'\n"})}),"\n",(0,i.jsxs)(t.p,{children:['The answer is indeed "',(0,i.jsx)(t.strong,{children:"hacker"}),'" for question ',(0,i.jsx)(t.strong,{children:"#7"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Question ",(0,i.jsx)(t.strong,{children:"#8"}),' is pretty straight forward, just go back to using the ProcessTree plugin and fetch the PPID of "powershell.exe".']}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(2288).A+"",title:"PSTree",width:"770",height:"752"})}),"\n",(0,i.jsxs)(t.p,{children:["For question ",(0,i.jsx)(t.strong,{children:"#9"}),', we need to investigate to find the full path and name of the last file opened in notepad. The CmdLine plugin is the way to go for this question. Indeed, we can go to the Process tab click on the notepad process, look at the "Cmdline" subtab and extract the answer which is ',(0,i.jsx)(t.code,{children:"C:\\Users\\JOHNDO~1\\AppData\\Local\\Temp\\7zO4FB31F24\\accountNum"}),"."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(9193).A+"",title:"PSTree",width:"294",height:"261"})}),"\n",(0,i.jsxs)(t.p,{children:["The last question is a little bit more tricky. Windows systems maintain a set of keys in the registry database (UserAssist keys) to keep track of programs that executed. We can use the UserAssist plugin and look for the execution of brave and how long it was used (Time Focused). The answer is ",(0,i.jsx)(t.strong,{children:"04:01:54"})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:s(1157).A+"",title:"PSTree",width:"1463",height:"165"})}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"To conclude this writeup, we were able to use the VolWeb platform to easly get answers and make our investigation more efficient. VolWeb is based on volatility3 and therefore doesn't fully cover all the cyberdefenders.org memory analysis challenges questions at the moment. Happy hunting !"})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},6938:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/2-14215d392ee1b6bb5a91e82fa46e80d2.png"},8068:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/7.1-ee6bbd501fedc73d6b941cd481739c31.png"},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var n=s(6540);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}},8540:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/4-b74cf91df1136ecb2bb9cae11391e9f4.png"},8826:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/1.1-2dbab51988457fb9443d322b1787a040.png"},9193:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/9-27ff8b18ba082b6a8c1016cb3ad01f33.png"},9806:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/6-03cccc2a9bfb95efc77487014be420bf.png"}}]);