"use strict";(self.webpackChunkexhume=self.webpackChunkexhume||[]).push([[200],{2678:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>g,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var i=n(4256),a=n(4848),o=n(8453);const l={slug:"volaslib",title:"\ud83d\udcd8 Using Volatility3 as a library",authors:["k1nd0ne"],tags:["DFIR","Volatility","Memory Forensics"]},s=void 0,r={authorsImageUrls:[void 0]},c=[{value:"Volatility3 CLI",id:"volatility3-cli",level:2},{value:"Constructing and running a plugin",id:"constructing-and-running-a-plugin",level:2},{value:"References",id:"references",level:2}];function u(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:'Being interested in memory forensic for a while now, I have learned a lot about the volatility3 framework. In this article, we will go through how you can use the framework\'s libraries to automate your memory analysis tasks and directly exploit the results. I will assume in this article that the reader has a basic understanding of how volatility3 is exploiting memory to extract evidence. If you want to learn more about volatility3, you can check the links in the "References" section.'}),"\n",(0,a.jsx)(t.h2,{id:"volatility3-cli",children:"Volatility3 CLI"}),"\n",(0,a.jsx)(t.p,{children:"When using the volatility3 framework on a memory image, the analyst is typically using the command line interface (CLI) component of the framework. It is one of the best way to interact with the framework quickly and get results. In the below example, we are executing the PsList plugin on a memory dump using the CLI."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"\n\xbb vol -r pretty -f Triage-Memory.mem windows.pslist\n  Volatility 3 Framework 2.0.1\n  Formatting...0.00\t\tPDB scanning finished\n    |  PID | PPID |  ImageFileName |      Offset(V) | Threads | Handles | SessionId | Wow64 |                  CreateTime | ExitTime | File output\n  * |    4 |    0 |         System | 0xfa8003c72b30 |      87 |     547 |       N/A | False | 2019-03-22 05:31:55.000000  |      N/A |    Disabled\n  * |  252 |    4 |       smss.exe | 0xfa8004616040 |       2 |      30 |       N/A | False | 2019-03-22 05:31:55.000000  |      N/A |    Disabled\n  * |  332 |  324 |      csrss.exe | 0xfa80050546b0 |      10 |     516 |         0 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n  * |  372 |  364 |      csrss.exe | 0xfa800525a9e0 |      11 |     557 |         1 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n  * |  380 |  324 |    wininit.exe | 0xfa8005259060 |       3 |      78 |         0 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n  * |  416 |  364 |   winlogon.exe | 0xfa8005268b30 |       3 |     110 |         1 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n  * |  476 |  380 |   services.exe | 0xfa8005680910 |      12 |     224 |         0 | False | 2019-03-22 05:31:59.000000  |      N/A |    Disabled\n  * |  484 |  380 |      lsass.exe | 0xfa80056885e0 |       7 |     650 |         0 | False | 2019-03-22 05:32:00.000000  |      N/A |    Disabled\n  * |  492 |  380 |        lsm.exe | 0xfa8005696b30 |      10 |     155 |         0 | False | 2019-03-22 05:32:00.000000  |      N/A |    Disabled\n  * |  592 |  476 |    svchost.exe | 0xfa80056e1060 |       9 |     375 |         0 | False | 2019-03-22 05:32:01.000000  |      N/A |    Disabled\n  * |  672 |  476 |    svchost.exe | 0xfa800570d060 |       7 |     341 |         0 | False | 2019-03-22 05:32:02.000000  |      N/A |    Disabled\n  * |  764 |  476 |    svchost.exe | 0xfa800575e5b0 |      20 |     447 |         0 | False | 2019-03-22 05:32:02.000000  |      N/A |    Disabled\n  * |  796 |  476 |    svchost.exe | 0xfa8005775b30 |      15 |     368 |         0 | False | 2019-03-22 05:32:03.000000  |      N/A |    Disabled\n  * |  820 |  476 |    svchost.exe | 0xfa800577db30 |      33 |    1073 |         0 | False | 2019-03-22 05:32:03.000000  |      N/A |    Disabled\n[etc...]\n\n"})}),"\n",(0,a.jsx)(t.p,{children:"Having those results is a great way to help you during an investigation, but what if we want to make the framework perform more specific tasks to include it to another platform ? For example, you may want to integrate the results directly inside a sandbox or a Web UI. Behind the scene of the execution of this command, volatility3 is using multiple libraries from the framework to produce its results. It's simply parsing the user's arguments and perform the following steps :"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Create an empty memory context for the memory image;"}),"\n",(0,a.jsx)(t.li,{children:"Determine if the requested plugin exists in the available list of plugins;"}),"\n",(0,a.jsx)(t.li,{children:"Determine what configuration options the plugin requires;"}),"\n",(0,a.jsx)(t.li,{children:"Complete the context configuration using the plugin requirements, automagics and the user's arguments;"}),"\n",(0,a.jsx)(t.li,{children:"Run the plugin;"}),"\n",(0,a.jsx)(t.li,{children:"Render the result into the desired format."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Great, now you have a high level understanding of what's going on in the background when attempting to run a plugin. Using the Volatility3 documentation, let's try to write a simple sample of code to run the PsList plugin with volatility3 as a library."}),"\n",(0,a.jsx)(t.h2,{id:"constructing-and-running-a-plugin",children:"Constructing and running a plugin"}),"\n",(0,a.jsx)(t.p,{children:"In this section we will take a look at how we can run the PsList pluging using volatility3 as a library. Let's first take a look at the following code sample :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'import volatility3.framework\nfrom volatility3.framework import contexts\nfrom volatility3 import plugins\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nvolatility3.framework.require_interface_version(2, 0, 0)\n\nctx = contexts.Context()  ## Construct a blank context\n\nfailures = volatility3.framework.import_files(plugins, True) ##Load the framework plugins\nif failures:\n    logger.info(f"Some volatility3 plugin couldn\'t be loaded : {failures}")\nelse:\n    logger.info(f"Plugins are loaded without failure")\nplugin_list = volatility3.framework.list_plugins()\nlogger.info(plugin_list)\n'})}),"\n",(0,a.jsx)(t.p,{children:"OUTPUT :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"INFO:__main__:Plugins are loaded without failure\nINFO:__main__:\n{\n'windows.statistics.Statistics': ,\n'timeliner.Timeliner': ,\n'windows.pslist.PsList': ,\n...\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"In this first step, we have constructed a blank context and loaded the native framework plugins. Next, we need to choose which plugin we want to run and construct the appropriate context based on its requirements. For this, I propose we create a function which can construct a simple plugin with no specific arguments."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"1    def build_context(image_name ,context, base_config_path, plugin):\n2        available_automagics = automagic.available(context)\n3        plugin_config_path = interfaces.configuration.path_join(base_config_path, plugin.__name__)\n4        automagics = automagic.choose_automagic(available_automagics, plugin)\n5        context.config['automagic.LayerStacker.stackers'] = automagic.stacker.choose_os_stackers(plugin)\n6        context.config['automagic.LayerStacker.single_location'] = \"file://\" + os.getcwd() + \"/\" + image_name\n7        constructed = construct_plugin(context, automagics, plugin, base_config_path, None, None)\n8        return constructed\n"})}),"\n",(0,a.jsx)(t.p,{children:"Let's decompose the function :"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.strong,{children:"image_name"})," : The name or relative path of the memory image you want to analyse."]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.strong,{children:"context"})," : The object in which the memory context, plugin configuration and requirements will be stored."]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.strong,{children:"base_config_path"})," : The path within the context's config containing the plugin's configuration. By default, this value is set to \"plugins\""]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.strong,{children:"plugin"})," : The plugin object choosen from the list of plugins."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'Volatility3 is using what is called "automagics" to help with plugin construction. Indeed it is helping a lot to automatically determine specific stack layers.\nLine 2, 4 and 5 of the code are determining what automagics are available, choose the automagics that apply to the operating system and update the context configuration.'}),"\n",(0,a.jsx)(t.p,{children:"Line 6 is simply giving the memory image location to the context configuration."}),"\n",(0,a.jsx)(t.p,{children:"Once the context is ready, we can construct the plugin using the framework built-in function \"construct_plugin\".\nThis function will check that all the plugin's requirements are fulfilled and if so, will return the constructed plugin (which is an object). The sample code and output below allows us to see a bit more of what happened behind the scene and construct the 'PsList' plugin.\nNotice that our logger also displays the volatility3 logs !"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'import volatility3.framework\nfrom volatility3.framework import contexts, interfaces\nfrom volatility3 import plugins\nfrom volatility3.framework import automagic\nfrom volatility3.framework.plugins import construct_plugin\nimport logging, os\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nvolatility3.framework.require_interface_version(2, 0, 0)\n\ndef build_context(image_name ,context, base_config_path, plugin):\n   available_automagics = automagic.available(context)\n   logger.info(f"Available automagics : {available_automagics}")\n   plugin_config_path = interfaces.configuration.path_join(base_config_path, plugin.__name__)\n   automagics = automagic.choose_automagic(available_automagics, plugin)\n   context.config[\'automagic.LayerStacker.stackers\'] = automagic.stacker.choose_os_stackers(plugin)\n   context.config[\'automagic.LayerStacker.single_location\'] = "file://" + os.getcwd() + "/" + image_name\n   constructed = construct_plugin(context, automagics, plugin, base_config_path, None, None)\n   logger.info(f"Contructed plugin : {constructed}")\n   return constructed\n\nctx = contexts.Context()  ## Construct a blank context\nfailures = volatility3.framework.import_files(plugins, True) ##Load the framework plugins\nif failures:\n   logger.info(f"Some volatility3 plugin couldn\'t be loaded : {failures}")\nelse:\n   logger.info(f"Plugins are loaded without failure")\nplugin_list = volatility3.framework.list_plugins()\nbase_config_path = "plugins"\n\nconstructed = build_context("Triage-Memory.mem", ctx, base_config_path, plugin_list[\'windows.pslist.PsList\'])\n\nlogger.info(f"Context configuration {ctx.config}")\n'})}),"\n",(0,a.jsx)(t.p,{children:"OUTPUT :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:' INFO:__main__:Plugins are loaded without failure\n INFO:__main__:Available automagics :\n [volatility3.framework.automagic.symbol_cache.SymbolBannerCache object at 0x1052d9e20,\n   volatility3.framework.automagic.mac.MacBannerCache object at 0x1052d9eb0,\n   volatility3.framework.automagic.linux.LinuxBannerCache object at 0x1052d9f40,\n   volatility3.framework.automagic.construct_layers.ConstructionMagic object at 0x1063a6340,\n   volatility3.framework.automagic.stacker.LayerStacker object at 0x1063b4280,\n   ...\n ]\n\n\n INFO:volatility3.framework.automagic:Detected a windows category plugin\n INFO:volatility3.framework.automagic:Running automagic: ConstructionMagic\n INFO:volatility3.framework.automagic:Running automagic: LayerStacker\n INFO:volatility3.framework.automagic:Running automagic: WinSwapLayers\n INFO:volatility3.framework.automagic:Running automagic: KernelPDBScanner\n INFO:volatility3.framework.automagic:Running automagic: KernelModule\n\n\n INFO:__main__:Contructed plugin : volatility3.plugins.windows.pslist.PsList object at 0x1063c1ee0\n\n\n INFO:__main__:Context configuration {\n   "automagic.LayerStacker.single_location": "file:///REDACTED/REDACTED/REDACTED/REDACTED/REDACTED/REDACTED/Triage-Memory.mem",\n   "automagic.LayerStacker.stackers": [\n     "AVMLStacker",\n     "LimeStacker",\n     "Elf64Stacker",\n     "QemuStacker",\n     "WindowsCrashDumpStacker",\n     "VmwareStacker",\n     "WindowsIntelStacker"\n   ],\n   "plugins.PsList.dump": false,\n   "plugins.PsList.kernel": "kernel",\n   "plugins.PsList.kernel.class": "volatility3.framework.contexts.Module",\n   "plugins.PsList.kernel.layer_name": "layer_name",\n   "plugins.PsList.kernel.layer_name.class": "volatility3.framework.layers.intel.WindowsIntel32e",\n   "plugins.PsList.kernel.layer_name.kernel_virtual_offset": 272678925664256,\n   "plugins.PsList.kernel.layer_name.memory_layer": "memory_layer",\n   "plugins.PsList.kernel.layer_name.memory_layer.class": "volatility3.framework.layers.physical.FileLayer",\n   "plugins.PsList.kernel.layer_name.memory_layer.location": "file:///REDACTED/REDACTED/REDACTED/REDACTED/REDACTED/REDACTED/Triage-Memory.mem",\n   "plugins.PsList.kernel.layer_name.page_map_offset": 1601536,\n   "plugins.PsList.kernel.layer_name.swap_layers": true,\n   "plugins.PsList.kernel.layer_name.swap_layers.number_of_elements": 0,\n   "plugins.PsList.kernel.offset": 272678925664256,\n   "plugins.PsList.kernel.symbol_table_name": "symbol_table_name1",\n   "plugins.PsList.kernel.symbol_table_name.class": "volatility3.framework.symbols.windows.WindowsKernelIntermedSymbols",\n   "plugins.PsList.kernel.symbol_table_name.isf_url": "file:///REDACTED/REDACTED/REDACTED/REDACTED/python/site-packages/volatility3/symbols/windows/ntkrnlmp.pdb/2E37F962D699492CAAF3F9F4E9770B1D-2.json.xz",\n   "plugins.PsList.kernel.symbol_table_name.symbol_mask": 0,\n   "plugins.PsList.physical": false,\n   "plugins.PsList.pid": []\n }\n'})}),"\n",(0,a.jsx)(t.p,{children:'Once our plugin is constructed, we can run it. However, we need to specify to volatility how we want to render the output. The framework is providing us with multiple renderers. Let\'s use the "pretty text renderer" that we have used with the CLI at the begining of the blog and run the plugin.'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'import volatility3.framework\nfrom volatility3.framework import contexts, interfaces\nfrom volatility3 import plugins\nfrom volatility3.framework import automagic\nfrom volatility3.framework.plugins import construct_plugin\nfrom volatility3.cli import text_renderer\nimport logging, os\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nvolatility3.framework.require_interface_version(2, 0, 0)\n\ndef build_context(image_name ,context, base_config_path, plugin):\n   available_automagics = automagic.available(context)\n   plugin_config_path = interfaces.configuration.path_join(base_config_path, plugin.__name__)\n   automagics = automagic.choose_automagic(available_automagics, plugin)\n   context.config[\'automagic.LayerStacker.stackers\'] = automagic.stacker.choose_os_stackers(plugin)\n   context.config[\'automagic.LayerStacker.single_location\'] = "file://" + os.getcwd() + "/" + image_name\n   constructed = construct_plugin(context, automagics, plugin, base_config_path, None, None)\n   return constructed\n\nctx = contexts.Context()  ## Construct a blank context\nfailures = volatility3.framework.import_files(plugins, True) ##Load the framework plugins\nif failures:\n   logger.info(f"Some volatility3 plugin couldn\'t be loaded : {failures}")\nelse:\n   logger.info(f"Plugins are loaded without failure")\nplugin_list = volatility3.framework.list_plugins()\nbase_config_path = "plugins"\nconstructed = build_context("Triage-Memory.mem", ctx, base_config_path, plugin_list[\'windows.pslist.PsList\'])\n\nif constructed:\n   result = text_renderer.PrettyTextRenderer().render(constructed.run())\n'})}),"\n",(0,a.jsx)(t.p,{children:"OUTPUT :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'INFO:__main__:Plugins are loaded without failure\nINFO:volatility3.framework.automagic:Detected a windows category plugin\nINFO:volatility3.framework.automagic:Running automagic: ConstructionMagic\nINFO:volatility3.framework.automagic:Running automagic: LayerStacker\nINFO:volatility3.framework.automagic:Running automagic: WinSwapLayers\nINFO:volatility3.framework.automagic:Running automagic: KernelPDBScanner\nINFO:volatility3.framework.automagic:Running automagic: KernelModule\nFormatting...\n |  PID | PPID |  ImageFileName |      Offset(V) | Threads | Handles | SessionId | Wow64 |                  CreateTime | ExitTime | File output\n* |    4 |    0 |         System | 0xfa8003c72b30 |      87 |     547 |       N/A | False | 2019-03-22 05:31:55.000000  |      N/A |    Disabled\n* |  252 |    4 |       smss.exe | 0xfa8004616040 |       2 |      30 |       N/A | False | 2019-03-22 05:31:55.000000  |      N/A |    Disabled\n* |  332 |  324 |      csrss.exe | 0xfa80050546b0 |      10 |     516 |         0 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n* |  372 |  364 |      csrss.exe | 0xfa800525a9e0 |      11 |     557 |         1 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n* |  380 |  324 |    wininit.exe | 0xfa8005259060 |       3 |      78 |         0 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n* |  416 |  364 |   winlogon.exe | 0xfa8005268b30 |       3 |     110 |         1 | False | 2019-03-22 05:31:58.000000  |      N/A |    Disabled\n* |  476 |  380 |   services.exe | 0xfa8005680910 |      12 |     224 |         0 | False | 2019-03-22 05:31:59.000000  |      N/A |    Disabled\n...\n\nGoing further\n\nGreat, we now know how to run a simple plugin with no specfic configuration and a default text renderer. In this section, we\'ll try to dump a specific process using the capabilities of the PsList plugin.\n\nIf you take a look at the context configuration displayed earlier, you\'ll notice that some options about the PsList plugin are set by default. What if we want to try to dump a specific process ? With the volatility3 CLI, the command is the following :\n\n\n\xbb vol -f Triage-Memory.mem windows.pslist --pid 252 --dump                                                                                                                             k1nd0ne@MacBook-Pro-de-Felix\nVolatility 3 Framework 2.0.1\nProgress:  100.00\t\tPDB scanning finished\nPID\tPPID\tImageFileName\tOffset(V)\tThreads\tHandles\tSessionId\tWow64\tCreateTime\tExitTime\tFile output\n\n252\t4\tsmss.exe\t0xfa8004616040\t2\t30\tN/A\tFalse\t2019-03-22 05:31:55.000000 \tN/A\tpid.252.0x48430000.dmp\n\nThe arguments we specified are the PID, which is the process ID we want to filter, and the DUMP option, which means that we want to dump the list of the filtered processes.\nIf we take a look at the plugin context configuration, the entries reponsible are the following :\n"plugins.PsList.pid": []\n"plugins.PsList.dump": false In our code, we just have to clarify those two values:\n\n\n...\nctx.config["plugins.PsList.pid"] = [252]\nctx.config["plugins.PsList.dump"] = True\nconstructed = build_context("Triage-Memory.mem", ctx, base_config_path, plugin_list[\'windows.pslist.PsList\'])\n'})}),"\n",(0,a.jsx)(t.p,{children:"OUTPUT :"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-1",metastring:"\u21b5 k1nd0ne@MacBook-Pro-de-Felix",children:"INFO:__main__:Plugins are loaded without failure\nINFO:volatility3.framework.automagic:Detected a windows category plugin\nINFO:volatility3.framework.automagic:Running automagic: ConstructionMagic\nINFO:volatility3.framework.automagic:Running automagic: LayerStacker\nINFO:volatility3.framework.automagic:Running automagic: WinSwapLayers\nINFO:volatility3.framework.automagic:Running automagic: KernelPDBScanner\nINFO:volatility3.framework.automagic:Running automagic: KernelModule\nFormatting...\n| PID | PPID | ImageFileName |      Offset(V) | Threads | Handles | SessionId | Wow64 |                  CreateTime | ExitTime |            File output\n* | 252 |    4 |      smss.exe | 0xfa8004616040 |       2 |      30 |       N/A | False | 2019-03-22 05:31:55.000000  |      N/A | pid.252.0x48430000.dmp\n"})}),"\n",(0,a.jsx)(t.p,{children:'This code will be interpreted without error. However you\'ll never find your process on your drive ! Why ? Well, in the "build_context" function, I have called the volatility3 framework\'s "construct_plugin" function with no File Handler Interface. By default, the volatility3 framework lets you decide how to handle files by rewritting the methods (open, write, ...). In this example, we want the file to be directly written in the current directory from where the script is executed. The following code is using the CLIDirectFileHandler from the native framework with a little bit of tweaking. Once integrated into our code, the final result looks like this :'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'import volatility3.framework\nfrom volatility3.framework import contexts, interfaces\nfrom volatility3 import plugins\nfrom volatility3.framework import automagic\nfrom volatility3.framework.plugins import construct_plugin\nfrom volatility3.cli import text_renderer\nimport logging, os, io, tempfile\n\n\ndef file_handler(output_dir):\n   class CLIFileHandler(interfaces.plugins.FileHandlerInterface):\n       """The FileHandler from Volatility3 CLI"""\n       def _get_final_filename(self):\n           """Gets the final filename"""\n           if output_dir is None:\n               raise TypeError("Output directory is not a string")\n           os.makedirs(output_dir, exist_ok = True)\n\n           pref_name_array = self.preferred_filename.split(\'.\')\n           filename, extension = os.path.join(output_dir, \'.\'.join(pref_name_array[:-1])), pref_name_array[-1]\n           output_filename = f"{filename}.{extension}"\n\n           counter = 1\n           if os.path.exists(output_filename):\n               os.remove(output_filename)\n           return output_filename\n\n   class CLIDirectFileHandler(CLIFileHandler):\n       """We want to save our files directly to disk"""\n       def __init__(self, filename: str):\n           fd, self._name = tempfile.mkstemp(suffix = \'.vol3\', prefix = \'tmp_\', dir = output_dir)\n           self._file = io.open(fd, mode = \'w+b\')\n           CLIFileHandler.__init__(self, filename)\n           for item in dir(self._file):\n               if not item.startswith(\'_\') and not item in [\'closed\', \'close\', \'mode\', \'name\']:\n                   setattr(self, item, getattr(self._file, item))\n\n       def __getattr__(self, item):\n           return getattr(self._file, item)\n\n       @property\n       def closed(self):\n           return self._file.closed\n\n       @property\n       def mode(self):\n           return self._file.mode\n\n       @property\n       def name(self):\n           return self._file.name\n\n       def close(self):\n           """Closes and commits the file (by moving the temporary file to the correct name"""\n           ## Don\'t overcommit\n           if self._file.closed:\n               return\n\n           self._file.close()\n           output_filename = self._get_final_filename()\n           os.rename(self._name, output_filename)\n\n   return CLIDirectFileHandler\n\ndef build_context(image_name ,context, base_config_path, plugin):\n   available_automagics = automagic.available(context)\n   plugin_config_path = interfaces.configuration.path_join(base_config_path, plugin.__name__)\n   automagics = automagic.choose_automagic(available_automagics, plugin)\n   context.config[\'automagic.LayerStacker.stackers\'] = automagic.stacker.choose_os_stackers(plugin)\n   context.config[\'automagic.LayerStacker.single_location\'] = "file://" + os.getcwd() + "/" + image_name\n   constructed = construct_plugin(context, automagics, plugin, base_config_path, None, file_handler(os.getcwd()))\n   return constructed\n\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nvolatility3.framework.require_interface_version(2, 0, 0)\n\nctx = contexts.Context()  ## Construct a blank context\nfailures = volatility3.framework.import_files(plugins, True) ##Load the framework plugins\nif failures:\n   logger.info(f"Some volatility3 plugin couldn\'t be loaded : {failures}")\nelse:\n   logger.info(f"Plugins are loaded without failure")\nplugin_list = volatility3.framework.list_plugins()\nbase_config_path = "plugins"\nctx.config["plugins.PsList.pid"] = [252]\nctx.config["plugins.PsList.dump"] = True\nconstructed = build_context("Triage-Memory.mem", ctx, base_config_path, plugin_list[\'windows.pslist.PsList\'])\n\nif constructed:\n   result = text_renderer.PrettyTextRenderer().render(constructed.run())\n'})}),"\n",(0,a.jsx)(t.p,{children:"There we go, when interpreted, this script will dump the process with PID 252 using the PsList plugin. Now that you know more about how to use the volatility3 framework libraries, you can imagine any application you want to a real case scenario!\nConclusion"}),"\n",(0,a.jsx)(t.p,{children:"I hope you now have a better understanding of how the volatility3 framework is working behind the scene, how easy it is to exploit and integrate it inside your investigation tools. You can of course write your own renderers to directly inject the results inside a database or any format that suite your needs. VolWeb is using volatility3 as a library and this article is directly linked to the latest release exploiting this capability.\nYou can check VolWeb by clicking the link below."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["This article is written from my own understanding of this subject and any critics you may have are welcomed to make this article evolve. You can contact me at ",(0,a.jsx)(t.a,{href:"mailto:felix.guyard@forensicxlab.com",children:"felix.guyard@forensicxlab.com"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"references",children:"References"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Volatility3 Documentation : ",(0,a.jsx)(t.a,{href:"https://volatility3.readthedocs.io/en/stable/using-as-a-library.html",children:"https://volatility3.readthedocs.io/en/stable/using-as-a-library.html"})]}),"\n",(0,a.jsxs)(t.li,{children:["Volatility3 Project : ",(0,a.jsx)(t.a,{href:"https://github.com/volatilityfoundation/volatility3",children:"https://github.com/volatilityfoundation/volatility3"})]}),"\n"]})]})}function g(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},4256:e=>{e.exports=JSON.parse('{"permalink":"/blog/volaslib","source":"@site/blog/2022-05-30-volaslib/index.md","title":"\ud83d\udcd8 Using Volatility3 as a library","description":"Being interested in memory forensic for a while now, I have learned a lot about the volatility3 framework. In this article, we will go through how you can use the framework\'s libraries to automate your memory analysis tasks and directly exploit the results. I will assume in this article that the reader has a basic understanding of how volatility3 is exploiting memory to extract evidence. If you want to learn more about volatility3, you can check the links in the \\"References\\" section.","date":"2022-05-30T00:00:00.000Z","tags":[{"inline":true,"label":"DFIR","permalink":"/blog/tags/dfir"},{"inline":true,"label":"Volatility","permalink":"/blog/tags/volatility"},{"inline":true,"label":"Memory Forensics","permalink":"/blog/tags/memory-forensics"}],"readingTime":13.075,"hasTruncateMarker":true,"authors":[{"name":"k1nd0ne","title":"Digital Forensics Spiderman","url":"https://github.com/k1n0ne","page":{"permalink":"/blog/authors/k-1-nd-0-ne"},"socials":{"x":"https://x.com/k1nd0ne","github":"https://github.com/k1nd0ne","bluesky":"https://bsky.app/profile/k1nd0ne.bsky.social"},"imageURL":"https://avatars.githubusercontent.com/u/27780432?v=4","key":"k1nd0ne"}],"frontMatter":{"slug":"volaslib","title":"\ud83d\udcd8 Using Volatility3 as a library","authors":["k1nd0ne"],"tags":["DFIR","Volatility","Memory Forensics"]},"unlisted":false,"prevItem":{"title":"\ud83d\udd8b Cyberdefenders - Writeup - Brave","permalink":"/blog/cb-brave"},"nextItem":{"title":"\ud83d\udcc4 Volatility3 - ISF for MacOs","permalink":"/blog/macisf"}}')},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>s});var i=n(6540);const a={},o=i.createContext(a);function l(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);